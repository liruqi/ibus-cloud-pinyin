/* config.c generated by valac 0.10.4, the Vala compiler
 * generated from config.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <float.h>
#include <math.h>
#include <ibus.h>
#include <gee.h>
#include <gobject/gvaluecollector.h>


#define ICP_TYPE_CONFIG (icp_config_get_type ())
#define ICP_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_TYPE_CONFIG, icpConfig))
#define ICP_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_TYPE_CONFIG, icpConfigClass))
#define ICP_IS_CONFIG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_TYPE_CONFIG))
#define ICP_IS_CONFIG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_TYPE_CONFIG))
#define ICP_CONFIG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_TYPE_CONFIG, icpConfigClass))

typedef struct _icpConfig icpConfig;
typedef struct _icpConfigClass icpConfigClass;
typedef struct _icpConfigPrivate icpConfigPrivate;
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _icpConfigCommandlineOptions icpConfigCommandlineOptions;
typedef struct _icpConfigTimeouts icpConfigTimeouts;

#define ICP_CONFIG_TYPE_COLORS (icp_config_colors_get_type ())
#define ICP_CONFIG_COLORS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_CONFIG_TYPE_COLORS, icpConfigColors))
#define ICP_CONFIG_COLORS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_CONFIG_TYPE_COLORS, icpConfigColorsClass))
#define ICP_CONFIG_IS_COLORS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_CONFIG_TYPE_COLORS))
#define ICP_CONFIG_IS_COLORS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_CONFIG_TYPE_COLORS))
#define ICP_CONFIG_COLORS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_CONFIG_TYPE_COLORS, icpConfigColorsClass))

typedef struct _icpConfigColors icpConfigColors;
typedef struct _icpConfigColorsClass icpConfigColorsClass;
typedef struct _icpConfigColorsPrivate icpConfigColorsPrivate;

#define ICP_CONFIG_COLORS_TYPE_COLOR (icp_config_colors_color_get_type ())
#define ICP_CONFIG_COLORS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_CONFIG_COLORS_TYPE_COLOR, icpConfigColorsColor))
#define ICP_CONFIG_COLORS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_CONFIG_COLORS_TYPE_COLOR, icpConfigColorsColorClass))
#define ICP_CONFIG_COLORS_IS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_CONFIG_COLORS_TYPE_COLOR))
#define ICP_CONFIG_COLORS_IS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_CONFIG_COLORS_TYPE_COLOR))
#define ICP_CONFIG_COLORS_COLOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_CONFIG_COLORS_TYPE_COLOR, icpConfigColorsColorClass))

typedef struct _icpConfigColorsColor icpConfigColorsColor;
typedef struct _icpConfigColorsColorClass icpConfigColorsColorClass;
#define _icp_config_colors_color_unref0(var) ((var == NULL) ? NULL : (var = (icp_config_colors_color_unref (var), NULL)))
typedef struct _icpConfigColorsColorPrivate icpConfigColorsColorPrivate;
typedef struct _icpConfigColorsParamSpecColor icpConfigColorsParamSpecColor;
typedef struct _icpConfigParamSpecColors icpConfigParamSpecColors;
typedef struct _icpConfigLimits icpConfigLimits;
typedef struct _icpConfigSwitches icpConfigSwitches;

#define ICP_CONFIG_TYPE_PUNCTUATIONS (icp_config_punctuations_get_type ())
#define ICP_CONFIG_PUNCTUATIONS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_CONFIG_TYPE_PUNCTUATIONS, icpConfigPunctuations))
#define ICP_CONFIG_PUNCTUATIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_CONFIG_TYPE_PUNCTUATIONS, icpConfigPunctuationsClass))
#define ICP_CONFIG_IS_PUNCTUATIONS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_CONFIG_TYPE_PUNCTUATIONS))
#define ICP_CONFIG_IS_PUNCTUATIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_CONFIG_TYPE_PUNCTUATIONS))
#define ICP_CONFIG_PUNCTUATIONS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_CONFIG_TYPE_PUNCTUATIONS, icpConfigPunctuationsClass))

typedef struct _icpConfigPunctuations icpConfigPunctuations;
typedef struct _icpConfigPunctuationsClass icpConfigPunctuationsClass;
typedef struct _icpConfigPunctuationsPrivate icpConfigPunctuationsPrivate;

#define ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION (icp_config_punctuations_full_punctuation_get_type ())
#define ICP_CONFIG_PUNCTUATIONS_FULL_PUNCTUATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION, icpConfigPunctuationsFullPunctuation))
#define ICP_CONFIG_PUNCTUATIONS_FULL_PUNCTUATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION, icpConfigPunctuationsFullPunctuationClass))
#define ICP_CONFIG_PUNCTUATIONS_IS_FULL_PUNCTUATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION))
#define ICP_CONFIG_PUNCTUATIONS_IS_FULL_PUNCTUATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION))
#define ICP_CONFIG_PUNCTUATIONS_FULL_PUNCTUATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION, icpConfigPunctuationsFullPunctuationClass))

typedef struct _icpConfigPunctuationsFullPunctuation icpConfigPunctuationsFullPunctuation;
typedef struct _icpConfigPunctuationsFullPunctuationClass icpConfigPunctuationsFullPunctuationClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _icp_config_punctuations_full_punctuation_unref0(var) ((var == NULL) ? NULL : (var = (icp_config_punctuations_full_punctuation_unref (var), NULL)))
typedef struct _icpConfigPunctuationsFullPunctuationPrivate icpConfigPunctuationsFullPunctuationPrivate;
typedef struct _icpConfigPunctuationsParamSpecFullPunctuation icpConfigPunctuationsParamSpecFullPunctuation;
typedef struct _icpConfigParamSpecPunctuations icpConfigParamSpecPunctuations;

#define ICP_CONFIG_TYPE_KEY (icp_config_key_get_type ())
#define ICP_CONFIG_KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_CONFIG_TYPE_KEY, icpConfigKey))
#define ICP_CONFIG_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_CONFIG_TYPE_KEY, icpConfigKeyClass))
#define ICP_CONFIG_IS_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_CONFIG_TYPE_KEY))
#define ICP_CONFIG_IS_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_CONFIG_TYPE_KEY))
#define ICP_CONFIG_KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_CONFIG_TYPE_KEY, icpConfigKeyClass))

typedef struct _icpConfigKey icpConfigKey;
typedef struct _icpConfigKeyClass icpConfigKeyClass;
typedef struct _icpConfigKeyPrivate icpConfigKeyPrivate;
typedef struct _icpConfigParamSpecKey icpConfigParamSpecKey;

#define ICP_CONFIG_TYPE_KEY_ACTIONS (icp_config_key_actions_get_type ())
#define ICP_CONFIG_KEY_ACTIONS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_CONFIG_TYPE_KEY_ACTIONS, icpConfigKeyActions))
#define ICP_CONFIG_KEY_ACTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_CONFIG_TYPE_KEY_ACTIONS, icpConfigKeyActionsClass))
#define ICP_CONFIG_IS_KEY_ACTIONS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_CONFIG_TYPE_KEY_ACTIONS))
#define ICP_CONFIG_IS_KEY_ACTIONS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_CONFIG_TYPE_KEY_ACTIONS))
#define ICP_CONFIG_KEY_ACTIONS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_CONFIG_TYPE_KEY_ACTIONS, icpConfigKeyActionsClass))

typedef struct _icpConfigKeyActions icpConfigKeyActions;
typedef struct _icpConfigKeyActionsClass icpConfigKeyActionsClass;
typedef struct _icpConfigKeyActionsPrivate icpConfigKeyActionsPrivate;
#define _icp_config_key_unref0(var) ((var == NULL) ? NULL : (var = (icp_config_key_unref (var), NULL)))
typedef struct _icpConfigParamSpecKeyActions icpConfigParamSpecKeyActions;

#define ICP_CONFIG_TYPE_CANDIDATE_LABELS (icp_config_candidate_labels_get_type ())
#define ICP_CONFIG_CANDIDATE_LABELS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_CONFIG_TYPE_CANDIDATE_LABELS, icpConfigCandidateLabels))
#define ICP_CONFIG_CANDIDATE_LABELS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_CONFIG_TYPE_CANDIDATE_LABELS, icpConfigCandidateLabelsClass))
#define ICP_CONFIG_IS_CANDIDATE_LABELS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_CONFIG_TYPE_CANDIDATE_LABELS))
#define ICP_CONFIG_IS_CANDIDATE_LABELS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_CONFIG_TYPE_CANDIDATE_LABELS))
#define ICP_CONFIG_CANDIDATE_LABELS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_CONFIG_TYPE_CANDIDATE_LABELS, icpConfigCandidateLabelsClass))

typedef struct _icpConfigCandidateLabels icpConfigCandidateLabels;
typedef struct _icpConfigCandidateLabelsClass icpConfigCandidateLabelsClass;
typedef struct _icpConfigCandidateLabelsPrivate icpConfigCandidateLabelsPrivate;
typedef struct _icpConfigParamSpecCandidateLabels icpConfigParamSpecCandidateLabels;
typedef struct _icpParamSpecConfig icpParamSpecConfig;

struct _icpConfig {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpConfigPrivate * priv;
};

struct _icpConfigClass {
	GTypeClass parent_class;
	void (*finalize) (icpConfig *self);
};

struct _icpConfigCommandlineOptions {
};

struct _icpConfigTimeouts {
};

struct _icpConfigColors {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpConfigColorsPrivate * priv;
};

struct _icpConfigColorsClass {
	GTypeClass parent_class;
	void (*finalize) (icpConfigColors *self);
};

struct _icpConfigColorsColor {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpConfigColorsColorPrivate * priv;
};

struct _icpConfigColorsColorClass {
	GTypeClass parent_class;
	void (*finalize) (icpConfigColorsColor *self);
};

struct _icpConfigColorsColorPrivate {
	gint* foreground;
	gint* background;
	gboolean underlined;
};

struct _icpConfigColorsParamSpecColor {
	GParamSpec parent_instance;
};

struct _icpConfigParamSpecColors {
	GParamSpec parent_instance;
};

struct _icpConfigLimits {
};

struct _icpConfigSwitches {
};

struct _icpConfigPunctuations {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpConfigPunctuationsPrivate * priv;
};

struct _icpConfigPunctuationsClass {
	GTypeClass parent_class;
	void (*finalize) (icpConfigPunctuations *self);
};

struct _icpConfigPunctuationsFullPunctuation {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpConfigPunctuationsFullPunctuationPrivate * priv;
};

struct _icpConfigPunctuationsFullPunctuationClass {
	GTypeClass parent_class;
	void (*finalize) (icpConfigPunctuationsFullPunctuation *self);
};

struct _icpConfigPunctuationsFullPunctuationPrivate {
	GeeArrayList* full_chars;
	gboolean _only_after_chinese;
	gint index;
};

struct _icpConfigPunctuationsParamSpecFullPunctuation {
	GParamSpec parent_instance;
};

struct _icpConfigParamSpecPunctuations {
	GParamSpec parent_instance;
};

struct _icpConfigKey {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpConfigKeyPrivate * priv;
};

struct _icpConfigKeyClass {
	GTypeClass parent_class;
	void (*finalize) (icpConfigKey *self);
};

struct _icpConfigKeyPrivate {
	guint _key;
	guint _state;
	char* _label;
};

struct _icpConfigParamSpecKey {
	GParamSpec parent_instance;
};

struct _icpConfigKeyActions {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpConfigKeyActionsPrivate * priv;
};

struct _icpConfigKeyActionsClass {
	GTypeClass parent_class;
	void (*finalize) (icpConfigKeyActions *self);
};

struct _icpConfigParamSpecKeyActions {
	GParamSpec parent_instance;
};

struct _icpConfigCandidateLabels {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpConfigCandidateLabelsPrivate * priv;
};

struct _icpConfigCandidateLabelsClass {
	GTypeClass parent_class;
	void (*finalize) (icpConfigCandidateLabels *self);
};

struct _icpConfigParamSpecCandidateLabels {
	GParamSpec parent_instance;
};

struct _icpParamSpecConfig {
	GParamSpec parent_instance;
};


static char* icp_config__global_data_path;
static char* icp_config__global_data_path = NULL;
static char* icp_config__user_database;
static char* icp_config__user_database = NULL;
static char* icp_config__global_database;
static char* icp_config__global_database = NULL;
static char* icp_config__program_scel_import;
static char* icp_config__program_scel_import = NULL;
static char* icp_config__program_main_icon;
static char* icp_config__program_main_icon = NULL;
static char* icp_config__user_config_path;
static char* icp_config__user_config_path = NULL;
static char* icp_config__user_data_path;
static char* icp_config__user_data_path = NULL;
static char* icp_config__user_cache_path;
static char* icp_config__user_cache_path = NULL;
static char* icp_config__program_main_file;
static char* icp_config__program_main_file = NULL;
static char* icp_config__program_path;
static char* icp_config__program_path = NULL;
static char* icp_config__program_request;
static char* icp_config__program_request = NULL;
extern gboolean icp_config_commandline_options_replace_running_process;
extern char* icp_config_commandline_options_startup_script;
extern gboolean icp_config_commandline_options_show_version;
extern gboolean icp_config_commandline_options_user_db_in_memory;
extern gboolean icp_config_commandline_options_launched_by_ibus;
extern gboolean icp_config_commandline_options_do_not_connect_ibus;
extern gboolean icp_config_commandline_options_show_xml;
char* icp_config_commandline_options_startup_script = NULL;
gboolean icp_config_commandline_options_show_version = FALSE;
gboolean icp_config_commandline_options_launched_by_ibus = FALSE;
gboolean icp_config_commandline_options_do_not_connect_ibus = FALSE;
gboolean icp_config_commandline_options_show_xml = FALSE;
gboolean icp_config_commandline_options_user_db_in_memory = FALSE;
gboolean icp_config_commandline_options_replace_running_process = FALSE;
extern double icp_config_timeouts_request;
double icp_config_timeouts_request = 15.0;
extern double icp_config_timeouts_prerequest;
double icp_config_timeouts_prerequest = 3.0;
extern double icp_config_timeouts_selection;
double icp_config_timeouts_selection = 2.0;
extern icpConfigColorsColor* icp_config_colors_buffer_raw;
icpConfigColorsColor* icp_config_colors_buffer_raw = NULL;
extern icpConfigColorsColor* icp_config_colors_buffer_pinyin;
icpConfigColorsColor* icp_config_colors_buffer_pinyin = NULL;
extern icpConfigColorsColor* icp_config_colors_candidate_local;
icpConfigColorsColor* icp_config_colors_candidate_local = NULL;
extern icpConfigColorsColor* icp_config_colors_candidate_remote;
icpConfigColorsColor* icp_config_colors_candidate_remote = NULL;
extern icpConfigColorsColor* icp_config_colors_preedit_correcting;
icpConfigColorsColor* icp_config_colors_preedit_correcting = NULL;
extern icpConfigColorsColor* icp_config_colors_preedit_local;
icpConfigColorsColor* icp_config_colors_preedit_local = NULL;
extern icpConfigColorsColor* icp_config_colors_preedit_remote;
icpConfigColorsColor* icp_config_colors_preedit_remote = NULL;
extern icpConfigColorsColor* icp_config_colors_preedit_fixed;
icpConfigColorsColor* icp_config_colors_preedit_fixed = NULL;
static gpointer icp_config_colors_color_parent_class = NULL;
static gpointer icp_config_colors_parent_class = NULL;
extern gint icp_config_limits_db_query_limit;
gint icp_config_limits_db_query_limit = 128;
extern gint icp_config_limits_prerequest_retry_limit;
gint icp_config_limits_prerequest_retry_limit = 3;
extern gint icp_config_limits_request_retry_limit;
gint icp_config_limits_request_retry_limit = 3;
extern gint icp_config_limits_cloud_candidates_limit;
gint icp_config_limits_cloud_candidates_limit = 4;
extern gboolean icp_config_switches_double_pinyin;
gboolean icp_config_switches_double_pinyin = FALSE;
extern gboolean icp_config_switches_background_request;
gboolean icp_config_switches_background_request = TRUE;
extern gboolean icp_config_switches_always_show_candidates;
gboolean icp_config_switches_always_show_candidates = TRUE;
extern gboolean icp_config_switches_show_pinyin_auxiliary;
gboolean icp_config_switches_show_pinyin_auxiliary = TRUE;
extern gboolean icp_config_switches_show_raw_in_auxiliary;
gboolean icp_config_switches_show_raw_in_auxiliary = TRUE;
extern gboolean icp_config_switches_default_offline_mode;
gboolean icp_config_switches_default_offline_mode = FALSE;
extern gboolean icp_config_switches_default_chinese_mode;
gboolean icp_config_switches_default_chinese_mode = TRUE;
extern gboolean icp_config_switches_default_traditional_mode;
gboolean icp_config_switches_default_traditional_mode = FALSE;
static GeeHashMap* icp_config_punctuations_punctuations;
static GeeHashMap* icp_config_punctuations_punctuations = NULL;
static gpointer icp_config_punctuations_full_punctuation_parent_class = NULL;
static gpointer icp_config_punctuations_parent_class = NULL;
static gpointer icp_config_key_parent_class = NULL;
static GeeHashMap* icp_config_key_actions_key_actions;
static GeeHashMap* icp_config_key_actions_key_actions = NULL;
static gpointer icp_config_key_actions_parent_class = NULL;
static GeeArrayList* icp_config_candidate_labels_labels;
static GeeArrayList* icp_config_candidate_labels_labels = NULL;
static gpointer icp_config_candidate_labels_parent_class = NULL;
static gpointer icp_config_parent_class = NULL;

gpointer icp_config_ref (gpointer instance);
void icp_config_unref (gpointer instance);
GParamSpec* icp_param_spec_config (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_value_set_config (GValue* value, gpointer v_object);
void icp_value_take_config (GValue* value, gpointer v_object);
gpointer icp_value_get_config (const GValue* value);
GType icp_config_get_type (void) G_GNUC_CONST;
enum  {
	ICP_CONFIG_DUMMY_PROPERTY
};
#define ICP_CONFIG_version "0.8.0.20101124"
#define ICP_CONFIG_prefix_path "/usr"
void icp_config_init (char*** args, int* args_length1);
static void icp_config_set_global_data_path (const char* value);
void icp_config_colors_init (void);
void icp_config_key_actions_init (void);
void icp_config_candidate_labels_init (void);
void icp_config_punctuations_init (void);
const char* icp_config_get_global_data_path (void);
static void icp_config_set_user_cache_path (const char* value);
static void icp_config_set_user_data_path (const char* value);
static void icp_config_set_user_config_path (const char* value);
const char* icp_config_get_user_cache_path (void);
static void icp_config_set_user_database (const char* value);
static void icp_config_set_global_database (const char* value);
static void icp_config_set_program_path (const char* value);
const char* icp_config_get_program_path (void);
static void icp_config_set_program_main_file (const char* value);
static void icp_config_set_program_main_icon (const char* value);
static void icp_config_set_program_scel_import (const char* value);
static void icp_config_set_program_request (const char* value);
static icpConfig* icp_config_new (void);
static icpConfig* icp_config_construct (GType object_type);
const char* icp_config_get_user_database (void);
const char* icp_config_get_global_database (void);
const char* icp_config_get_program_scel_import (void);
const char* icp_config_get_program_main_icon (void);
const char* icp_config_get_user_config_path (void);
const char* icp_config_get_user_data_path (void);
const char* icp_config_get_program_main_file (void);
const char* icp_config_get_program_request (void);
void icp_config_commandline_options_free (icpConfigCommandlineOptions* self);
icpConfigCommandlineOptions* icp_config_commandline_options_new (void);
icpConfigCommandlineOptions* icp_config_commandline_options_new (void);
static void icp_config_commandline_options_instance_init (icpConfigCommandlineOptions * self);
void icp_config_timeouts_free (icpConfigTimeouts* self);
icpConfigTimeouts* icp_config_timeouts_new (void);
icpConfigTimeouts* icp_config_timeouts_new (void);
static void icp_config_timeouts_instance_init (icpConfigTimeouts * self);
gpointer icp_config_colors_ref (gpointer instance);
void icp_config_colors_unref (gpointer instance);
GParamSpec* icp_config_param_spec_colors (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_config_value_set_colors (GValue* value, gpointer v_object);
void icp_config_value_take_colors (GValue* value, gpointer v_object);
gpointer icp_config_value_get_colors (const GValue* value);
GType icp_config_colors_get_type (void) G_GNUC_CONST;
enum  {
	ICP_CONFIG_COLORS_DUMMY_PROPERTY
};
gpointer icp_config_colors_color_ref (gpointer instance);
void icp_config_colors_color_unref (gpointer instance);
GParamSpec* icp_config_colors_param_spec_color (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_config_colors_value_set_color (GValue* value, gpointer v_object);
void icp_config_colors_value_take_color (GValue* value, gpointer v_object);
gpointer icp_config_colors_value_get_color (const GValue* value);
GType icp_config_colors_color_get_type (void) G_GNUC_CONST;
static icpConfigColors* icp_config_colors_new (void);
static icpConfigColors* icp_config_colors_construct (GType object_type);
icpConfigColorsColor* icp_config_colors_color_new (gint* foreground, gint* background, gboolean underlined);
icpConfigColorsColor* icp_config_colors_color_construct (GType object_type, gint* foreground, gint* background, gboolean underlined);
#define ICP_CONFIG_COLORS_COLOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ICP_CONFIG_COLORS_TYPE_COLOR, icpConfigColorsColorPrivate))
enum  {
	ICP_CONFIG_COLORS_COLOR_DUMMY_PROPERTY
};
static gint* _int_dup (gint* self);
void icp_config_colors_color_apply (icpConfigColorsColor* self, IBusText* text, guint start, gint end);
static void icp_config_colors_color_finalize (icpConfigColorsColor* obj);
static void icp_config_colors_finalize (icpConfigColors* obj);
void icp_config_limits_free (icpConfigLimits* self);
icpConfigLimits* icp_config_limits_new (void);
icpConfigLimits* icp_config_limits_new (void);
static void icp_config_limits_instance_init (icpConfigLimits * self);
void icp_config_switches_free (icpConfigSwitches* self);
icpConfigSwitches* icp_config_switches_new (void);
icpConfigSwitches* icp_config_switches_new (void);
static void icp_config_switches_instance_init (icpConfigSwitches * self);
gpointer icp_config_punctuations_ref (gpointer instance);
void icp_config_punctuations_unref (gpointer instance);
GParamSpec* icp_config_param_spec_punctuations (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_config_value_set_punctuations (GValue* value, gpointer v_object);
void icp_config_value_take_punctuations (GValue* value, gpointer v_object);
gpointer icp_config_value_get_punctuations (const GValue* value);
GType icp_config_punctuations_get_type (void) G_GNUC_CONST;
enum  {
	ICP_CONFIG_PUNCTUATIONS_DUMMY_PROPERTY
};
gpointer icp_config_punctuations_full_punctuation_ref (gpointer instance);
void icp_config_punctuations_full_punctuation_unref (gpointer instance);
GParamSpec* icp_config_punctuations_param_spec_full_punctuation (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_config_punctuations_value_set_full_punctuation (GValue* value, gpointer v_object);
void icp_config_punctuations_value_take_full_punctuation (GValue* value, gpointer v_object);
gpointer icp_config_punctuations_value_get_full_punctuation (const GValue* value);
GType icp_config_punctuations_full_punctuation_get_type (void) G_GNUC_CONST;
static icpConfigPunctuations* icp_config_punctuations_new (void);
static icpConfigPunctuations* icp_config_punctuations_construct (GType object_type);
void icp_config_punctuations_set (gint half_char, const char* full_chars, gboolean only_after_chinese);
icpConfigPunctuationsFullPunctuation* icp_config_punctuations_full_punctuation_new (const char* full_chars, gboolean only_after_chinese);
icpConfigPunctuationsFullPunctuation* icp_config_punctuations_full_punctuation_construct (GType object_type, const char* full_chars, gboolean only_after_chinese);
char* icp_config_punctuations_get (gint key, gboolean after_chinese);
gboolean icp_config_punctuations_full_punctuation_get_only_after_chinese (icpConfigPunctuationsFullPunctuation* self);
char* icp_config_punctuations_full_punctuation_get_full_char (icpConfigPunctuationsFullPunctuation* self);
gboolean icp_config_punctuations_exists (gint key);
#define ICP_CONFIG_PUNCTUATIONS_FULL_PUNCTUATION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION, icpConfigPunctuationsFullPunctuationPrivate))
enum  {
	ICP_CONFIG_PUNCTUATIONS_FULL_PUNCTUATION_DUMMY_PROPERTY
};
static void icp_config_punctuations_full_punctuation_set_only_after_chinese (icpConfigPunctuationsFullPunctuation* self, gboolean value);
static void icp_config_punctuations_full_punctuation_finalize (icpConfigPunctuationsFullPunctuation* obj);
static void icp_config_punctuations_finalize (icpConfigPunctuations* obj);
gpointer icp_config_key_ref (gpointer instance);
void icp_config_key_unref (gpointer instance);
GParamSpec* icp_config_param_spec_key (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_config_value_set_key (GValue* value, gpointer v_object);
void icp_config_value_take_key (GValue* value, gpointer v_object);
gpointer icp_config_value_get_key (const GValue* value);
GType icp_config_key_get_type (void) G_GNUC_CONST;
#define ICP_CONFIG_KEY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ICP_CONFIG_TYPE_KEY, icpConfigKeyPrivate))
enum  {
	ICP_CONFIG_KEY_DUMMY_PROPERTY
};
icpConfigKey* icp_config_key_new (guint key, guint state, const char* label);
icpConfigKey* icp_config_key_construct (GType object_type, guint key, guint state, const char* label);
static void icp_config_key_set_key (icpConfigKey* self, guint value);
static void icp_config_key_set_state (icpConfigKey* self, guint value);
static void icp_config_key_set_label (icpConfigKey* self, const char* value);
guint icp_config_key_hash_func (icpConfigKey* a);
guint icp_config_key_get_key (icpConfigKey* self);
guint icp_config_key_get_state (icpConfigKey* self);
gboolean icp_config_key_equal_func (icpConfigKey* a, icpConfigKey* b);
const char* icp_config_key_get_label (icpConfigKey* self);
static void icp_config_key_finalize (icpConfigKey* obj);
gpointer icp_config_key_actions_ref (gpointer instance);
void icp_config_key_actions_unref (gpointer instance);
GParamSpec* icp_config_param_spec_key_actions (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_config_value_set_key_actions (GValue* value, gpointer v_object);
void icp_config_value_take_key_actions (GValue* value, gpointer v_object);
gpointer icp_config_value_get_key_actions (const GValue* value);
GType icp_config_key_actions_get_type (void) G_GNUC_CONST;
enum  {
	ICP_CONFIG_KEY_ACTIONS_DUMMY_PROPERTY
};
static icpConfigKeyActions* icp_config_key_actions_new (void);
static icpConfigKeyActions* icp_config_key_actions_construct (GType object_type);
void icp_config_key_actions_set (icpConfigKey* key, const char* action);
char* icp_config_key_actions_get (icpConfigKey* key);
static void icp_config_key_actions_finalize (icpConfigKeyActions* obj);
gpointer icp_config_candidate_labels_ref (gpointer instance);
void icp_config_candidate_labels_unref (gpointer instance);
GParamSpec* icp_config_param_spec_candidate_labels (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_config_value_set_candidate_labels (GValue* value, gpointer v_object);
void icp_config_value_take_candidate_labels (GValue* value, gpointer v_object);
gpointer icp_config_value_get_candidate_labels (const GValue* value);
GType icp_config_candidate_labels_get_type (void) G_GNUC_CONST;
enum  {
	ICP_CONFIG_CANDIDATE_LABELS_DUMMY_PROPERTY
};
static icpConfigCandidateLabels* icp_config_candidate_labels_new (void);
static icpConfigCandidateLabels* icp_config_candidate_labels_construct (GType object_type);
void icp_config_candidate_labels_clear (void);
void icp_config_candidate_labels_add (const char* label, const char* label_alternative);
void icp_config_candidate_labels_set (gint index, const char* label, const char* label_alternative);
gint icp_config_candidate_labels_get_size (void);
char* icp_config_candidate_labels_get (gint index, gboolean use_alternative);
static void icp_config_candidate_labels_finalize (icpConfigCandidateLabels* obj);
static void icp_config_finalize (icpConfig* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);



void icp_config_init (char*** args, int* args_length1) {
	GOptionEntry _tmp0_ = {0};
	GOptionEntry entrie_replace;
	GOptionEntry _tmp1_ = {0};
	GOptionEntry entrie_script;
	GOptionEntry _tmp2_ = {0};
	GOptionEntry entrie_version;
	GOptionEntry _tmp3_ = {0};
	GOptionEntry entrie_user_db_in_mem;
	GOptionEntry _tmp4_ = {0};
	GOptionEntry entrie_ibus;
	GOptionEntry _tmp5_ = {0};
	GOptionEntry entrie_no_ibus;
	GOptionEntry _tmp6_ = {0};
	GOptionEntry entrie_xml;
	GOptionEntry _tmp7_ = {0};
	GOptionEntry entrie_null;
	GOptionContext* context;
	GOptionEntry* _tmp8_ = NULL;
	GOptionEntry* _tmp9_;
	gint _tmp9__length1;
	char* _tmp11_;
	char* _tmp12_;
	char* _tmp13_;
	char* _tmp14_;
	char* _tmp17_;
	char* _tmp18_;
	char* _tmp19_;
	char* _tmp20_;
	char* _tmp21_;
	char* _tmp22_;
	GError * _inner_error_ = NULL;
	icp_config_set_global_data_path (ICP_CONFIG_prefix_path "/share/ibus-cloud-pinyin");
	icp_config_colors_init ();
	icp_config_key_actions_init ();
	icp_config_candidate_labels_init ();
	icp_config_punctuations_init ();
	entrie_replace = (_tmp0_.long_name = "replace", _tmp0_.short_name = 'r', _tmp0_.flags = 0, _tmp0_.arg = G_OPTION_ARG_NONE, _tmp0_.arg_data = &icp_config_commandline_options_replace_running_process, _tmp0_.description = "Replace running cloud pinyin engine", _tmp0_.arg_description = NULL, _tmp0_);
	entrie_script = (_tmp1_.long_name = "script", _tmp1_.short_name = 'c', _tmp1_.flags = 0, _tmp1_.arg = G_OPTION_ARG_FILENAME, _tmp1_.arg_data = &icp_config_commandline_options_startup_script, _tmp1_.description = "Specify a (startup) script", _tmp1_.arg_description = "filename", _tmp1_);
	entrie_version = (_tmp2_.long_name = "version", _tmp2_.short_name = 'i', _tmp2_.flags = 0, _tmp2_.arg = G_OPTION_ARG_NONE, _tmp2_.arg_data = &icp_config_commandline_options_show_version, _tmp2_.description = "Show version information", _tmp2_.arg_description = NULL, _tmp2_);
	entrie_user_db_in_mem = (_tmp3_.long_name = "userdb-in-memory", _tmp3_.short_name = 'm', _tmp3_.flags = 0, _tmp3_.arg = G_OPTION_ARG_NONE, _tmp3_.arg_data = &icp_config_commandline_options_user_db_in_memory, _tmp3_.description = "Store user database in memory", _tmp3_.arg_description = NULL, _tmp3_);
	entrie_ibus = (_tmp4_.long_name = "ibus", _tmp4_.short_name = 'b', _tmp4_.flags = 0, _tmp4_.arg = G_OPTION_ARG_NONE, _tmp4_.arg_data = &icp_config_commandline_options_launched_by_ibus, _tmp4_.description = "Take ownship of registered ibus component", _tmp4_.arg_description = NULL, _tmp4_);
	entrie_no_ibus = (_tmp5_.long_name = "no-ibus", _tmp5_.short_name = 'n', _tmp5_.flags = 0, _tmp5_.arg = G_OPTION_ARG_NONE, _tmp5_.arg_data = &icp_config_commandline_options_do_not_connect_ibus, _tmp5_.description = "Do not connect to ibus-daemon", _tmp5_.arg_description = NULL, _tmp5_);
	entrie_xml = (_tmp6_.long_name = "dump-xml", _tmp6_.short_name = 'x', _tmp6_.flags = 0, _tmp6_.arg = G_OPTION_ARG_NONE, _tmp6_.arg_data = &icp_config_commandline_options_show_xml, _tmp6_.description = "Dump ibus component xml", _tmp6_.arg_description = NULL, _tmp6_);
	entrie_null = (_tmp7_.long_name = NULL, _tmp7_);
	context = g_option_context_new ("- cloud pinyin client for ibus");
	g_option_context_add_main_entries (context, (_tmp9_ = (_tmp8_ = g_new0 (GOptionEntry, 8), _tmp8_[0] = entrie_version, _tmp8_[1] = entrie_script, _tmp8_[2] = entrie_ibus, _tmp8_[3] = entrie_no_ibus, _tmp8_[4] = entrie_xml, _tmp8_[5] = entrie_user_db_in_mem, _tmp8_[6] = entrie_replace, _tmp8_[7] = entrie_null, _tmp8_), _tmp9__length1 = 8, _tmp9_), NULL);
	_tmp9_ = (g_free (_tmp9_), NULL);
	{
		g_option_context_parse (context, args_length1, args, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_OPTION_ERROR) {
				goto __catch9_g_option_error;
			}
			_g_option_context_free0 (context);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	goto __finally9;
	__catch9_g_option_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			fprintf (stderr, "option parsing failed: %s\n", e->message);
			_g_error_free0 (e);
		}
	}
	__finally9:
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (context);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	if (icp_config_commandline_options_startup_script == NULL) {
		char* _tmp10_;
		icp_config_commandline_options_startup_script = (_tmp10_ = g_strconcat (icp_config_get_global_data_path (), "/lua/config.lua", NULL), _g_free0 (icp_config_commandline_options_startup_script), _tmp10_);
	}
	icp_config_set_user_cache_path (_tmp11_ = g_strdup_printf ("%s/ibus/cloud-pinyin", g_get_user_cache_dir ()));
	_g_free0 (_tmp11_);
	icp_config_set_user_data_path (_tmp12_ = g_strdup_printf ("%s/ibus/cloud-pinyin", g_get_user_data_dir ()));
	_g_free0 (_tmp12_);
	icp_config_set_user_config_path (_tmp13_ = g_strdup_printf ("%s/ibus/cloud-pinyin", g_get_user_config_dir ()));
	_g_free0 (_tmp13_);
	_tmp14_ = NULL;
	if (icp_config_commandline_options_user_db_in_memory) {
		char* _tmp15_;
		_tmp14_ = (_tmp15_ = g_strdup (":memory:"), _g_free0 (_tmp14_), _tmp15_);
	} else {
		char* _tmp16_;
		_tmp14_ = (_tmp16_ = g_strdup_printf ("%s/userdb.db", icp_config_get_user_cache_path ()), _g_free0 (_tmp14_), _tmp16_);
	}
	icp_config_set_user_database (_tmp14_);
	icp_config_set_global_database (_tmp17_ = g_strdup_printf ("%s/db/main.db", icp_config_get_global_data_path ()));
	_g_free0 (_tmp17_);
	icp_config_set_program_path (_tmp18_ = g_get_current_dir ());
	_g_free0 (_tmp18_);
	icp_config_set_program_main_file (_tmp19_ = g_strdup_printf ("%s/%s", icp_config_get_program_path (), (*args)[0]));
	_g_free0 (_tmp19_);
	icp_config_set_program_main_icon (_tmp20_ = g_strconcat (icp_config_get_global_data_path (), "/icons/ibus-cloud-pinyin.png", NULL));
	_g_free0 (_tmp20_);
	icp_config_set_program_scel_import (_tmp21_ = g_strdup_printf ("%s/lib/ibus-cloud-pinyin/scel-import-selector.py", ICP_CONFIG_prefix_path));
	_g_free0 (_tmp21_);
	icp_config_set_program_request (_tmp22_ = g_strdup_printf ("%s/lib/ibus-cloud-pinyin/ibus-cloud-pinyin-request", ICP_CONFIG_prefix_path));
	_g_free0 (_tmp22_);
	_g_free0 (_tmp14_);
	_g_option_context_free0 (context);
}


static icpConfig* icp_config_construct (GType object_type) {
	icpConfig* self = (icpConfig*) g_type_create_instance (object_type);
	return self;
}


static icpConfig* icp_config_new (void) {
	return icp_config_construct (ICP_TYPE_CONFIG);
}


const char* icp_config_get_global_data_path (void) {
	const char* result;
	result = icp_config__global_data_path;
	return result;
}


static void icp_config_set_global_data_path (const char* value) {
	char* _tmp0_;
	icp_config__global_data_path = (_tmp0_ = g_strdup (value), _g_free0 (icp_config__global_data_path), _tmp0_);
}


const char* icp_config_get_user_database (void) {
	const char* result;
	result = icp_config__user_database;
	return result;
}


static void icp_config_set_user_database (const char* value) {
	char* _tmp0_;
	icp_config__user_database = (_tmp0_ = g_strdup (value), _g_free0 (icp_config__user_database), _tmp0_);
}


const char* icp_config_get_global_database (void) {
	const char* result;
	result = icp_config__global_database;
	return result;
}


static void icp_config_set_global_database (const char* value) {
	char* _tmp0_;
	icp_config__global_database = (_tmp0_ = g_strdup (value), _g_free0 (icp_config__global_database), _tmp0_);
}


const char* icp_config_get_program_scel_import (void) {
	const char* result;
	result = icp_config__program_scel_import;
	return result;
}


static void icp_config_set_program_scel_import (const char* value) {
	char* _tmp0_;
	icp_config__program_scel_import = (_tmp0_ = g_strdup (value), _g_free0 (icp_config__program_scel_import), _tmp0_);
}


const char* icp_config_get_program_main_icon (void) {
	const char* result;
	result = icp_config__program_main_icon;
	return result;
}


static void icp_config_set_program_main_icon (const char* value) {
	char* _tmp0_;
	icp_config__program_main_icon = (_tmp0_ = g_strdup (value), _g_free0 (icp_config__program_main_icon), _tmp0_);
}


const char* icp_config_get_user_config_path (void) {
	const char* result;
	result = icp_config__user_config_path;
	return result;
}


static void icp_config_set_user_config_path (const char* value) {
	char* _tmp0_;
	icp_config__user_config_path = (_tmp0_ = g_strdup (value), _g_free0 (icp_config__user_config_path), _tmp0_);
}


const char* icp_config_get_user_data_path (void) {
	const char* result;
	result = icp_config__user_data_path;
	return result;
}


static void icp_config_set_user_data_path (const char* value) {
	char* _tmp0_;
	icp_config__user_data_path = (_tmp0_ = g_strdup (value), _g_free0 (icp_config__user_data_path), _tmp0_);
}


const char* icp_config_get_user_cache_path (void) {
	const char* result;
	result = icp_config__user_cache_path;
	return result;
}


static void icp_config_set_user_cache_path (const char* value) {
	char* _tmp0_;
	icp_config__user_cache_path = (_tmp0_ = g_strdup (value), _g_free0 (icp_config__user_cache_path), _tmp0_);
}


const char* icp_config_get_program_main_file (void) {
	const char* result;
	result = icp_config__program_main_file;
	return result;
}


static void icp_config_set_program_main_file (const char* value) {
	char* _tmp0_;
	icp_config__program_main_file = (_tmp0_ = g_strdup (value), _g_free0 (icp_config__program_main_file), _tmp0_);
}


const char* icp_config_get_program_path (void) {
	const char* result;
	result = icp_config__program_path;
	return result;
}


static void icp_config_set_program_path (const char* value) {
	char* _tmp0_;
	icp_config__program_path = (_tmp0_ = g_strdup (value), _g_free0 (icp_config__program_path), _tmp0_);
}


const char* icp_config_get_program_request (void) {
	const char* result;
	result = icp_config__program_request;
	return result;
}


static void icp_config_set_program_request (const char* value) {
	char* _tmp0_;
	icp_config__program_request = (_tmp0_ = g_strdup (value), _g_free0 (icp_config__program_request), _tmp0_);
}


icpConfigCommandlineOptions* icp_config_commandline_options_new (void) {
	icpConfigCommandlineOptions* self;
	self = g_slice_new0 (icpConfigCommandlineOptions);
	icp_config_commandline_options_instance_init (self);
	g_assert_not_reached ();
	return self;
}


static void icp_config_commandline_options_instance_init (icpConfigCommandlineOptions * self) {
}


void icp_config_commandline_options_free (icpConfigCommandlineOptions* self) {
	g_slice_free (icpConfigCommandlineOptions, self);
}


icpConfigTimeouts* icp_config_timeouts_new (void) {
	icpConfigTimeouts* self;
	self = g_slice_new0 (icpConfigTimeouts);
	icp_config_timeouts_instance_init (self);
	g_assert_not_reached ();
	return self;
}


static void icp_config_timeouts_instance_init (icpConfigTimeouts * self) {
}


void icp_config_timeouts_free (icpConfigTimeouts* self) {
	g_slice_free (icpConfigTimeouts, self);
}


static icpConfigColors* icp_config_colors_construct (GType object_type) {
	icpConfigColors* self = (icpConfigColors*) g_type_create_instance (object_type);
	g_assert_not_reached ();
	return self;
}


static icpConfigColors* icp_config_colors_new (void) {
	return icp_config_colors_construct (ICP_CONFIG_TYPE_COLORS);
}


void icp_config_colors_init (void) {
	gint _tmp0_;
	icpConfigColorsColor* _tmp1_;
	icpConfigColorsColor* _tmp2_;
	icpConfigColorsColor* _tmp3_;
	gint _tmp4_;
	icpConfigColorsColor* _tmp5_;
	gint _tmp6_;
	icpConfigColorsColor* _tmp7_;
	gint _tmp8_;
	icpConfigColorsColor* _tmp9_;
	gint _tmp10_;
	icpConfigColorsColor* _tmp11_;
	gint _tmp12_;
	icpConfigColorsColor* _tmp13_;
	icp_config_colors_buffer_raw = (_tmp1_ = icp_config_colors_color_new ((_tmp0_ = 0x00B75D, &_tmp0_), NULL, FALSE), _icp_config_colors_color_unref0 (icp_config_colors_buffer_raw), _tmp1_);
	icp_config_colors_buffer_pinyin = (_tmp2_ = icp_config_colors_color_new (NULL, NULL, TRUE), _icp_config_colors_color_unref0 (icp_config_colors_buffer_pinyin), _tmp2_);
	icp_config_colors_candidate_local = (_tmp3_ = icp_config_colors_color_new (NULL, NULL, FALSE), _icp_config_colors_color_unref0 (icp_config_colors_candidate_local), _tmp3_);
	icp_config_colors_candidate_remote = (_tmp5_ = icp_config_colors_color_new ((_tmp4_ = 0x0050FF, &_tmp4_), NULL, FALSE), _icp_config_colors_color_unref0 (icp_config_colors_candidate_remote), _tmp5_);
	icp_config_colors_preedit_correcting = (_tmp7_ = icp_config_colors_color_new (NULL, (_tmp6_ = 0xFFB442, &_tmp6_), FALSE), _icp_config_colors_color_unref0 (icp_config_colors_preedit_correcting), _tmp7_);
	icp_config_colors_preedit_local = (_tmp9_ = icp_config_colors_color_new ((_tmp8_ = 0x8C8C8C, &_tmp8_), NULL, FALSE), _icp_config_colors_color_unref0 (icp_config_colors_preedit_local), _tmp9_);
	icp_config_colors_preedit_remote = (_tmp11_ = icp_config_colors_color_new ((_tmp10_ = 0x0D88FF, &_tmp10_), NULL, FALSE), _icp_config_colors_color_unref0 (icp_config_colors_preedit_remote), _tmp11_);
	icp_config_colors_preedit_fixed = (_tmp13_ = icp_config_colors_color_new ((_tmp12_ = 0x242322, &_tmp12_), NULL, FALSE), _icp_config_colors_color_unref0 (icp_config_colors_preedit_fixed), _tmp13_);
}


static gint* _int_dup (gint* self) {
	gint* dup;
	dup = g_new0 (gint, 1);
	memcpy (dup, self, sizeof (gint));
	return dup;
}


static gpointer __int_dup0 (gpointer self) {
	return self ? _int_dup (self) : NULL;
}


icpConfigColorsColor* icp_config_colors_color_construct (GType object_type, gint* foreground, gint* background, gboolean underlined) {
	icpConfigColorsColor* self = (icpConfigColorsColor*) g_type_create_instance (object_type);
	gint* _tmp0_;
	gint* _tmp1_;
	self->priv->foreground = (_tmp0_ = __int_dup0 (foreground), _g_free0 (self->priv->foreground), _tmp0_);
	self->priv->background = (_tmp1_ = __int_dup0 (background), _g_free0 (self->priv->background), _tmp1_);
	self->priv->underlined = underlined;
	return self;
}


icpConfigColorsColor* icp_config_colors_color_new (gint* foreground, gint* background, gboolean underlined) {
	return icp_config_colors_color_construct (ICP_CONFIG_COLORS_TYPE_COLOR, foreground, background, underlined);
}


void icp_config_colors_color_apply (icpConfigColorsColor* self, IBusText* text, guint start, gint end) {
	g_return_if_fail (ICP_CONFIG_COLORS_IS_COLOR (self));
	g_return_if_fail (IBUS_IS_TEXT (text));
	if (end == (-1)) {
		end = (gint) ibus_text_get_length (text);
	}
	if (((gint) start) >= end) {
		return;
	}
	if (self->priv->underlined) {
		ibus_text_append_attribute (text, (guint) IBUS_ATTR_TYPE_UNDERLINE, (guint) IBUS_ATTR_UNDERLINE_SINGLE, start, end);
	}
	if (self->priv->foreground != NULL) {
		ibus_text_append_attribute (text, (guint) IBUS_ATTR_TYPE_FOREGROUND, *self->priv->foreground, start, end);
	}
	if (self->priv->background != NULL) {
		ibus_text_append_attribute (text, (guint) IBUS_ATTR_TYPE_BACKGROUND, *self->priv->background, start, end);
	}
}


static void icp_config_colors_value_color_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_config_colors_value_color_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_config_colors_color_unref (value->data[0].v_pointer);
	}
}


static void icp_config_colors_value_color_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_config_colors_color_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_config_colors_value_color_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_config_colors_value_color_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpConfigColorsColor* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_config_colors_color_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_config_colors_value_color_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpConfigColorsColor** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_config_colors_color_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* icp_config_colors_param_spec_color (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpConfigColorsParamSpecColor* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_CONFIG_COLORS_TYPE_COLOR), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer icp_config_colors_value_get_color (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_COLORS_TYPE_COLOR), NULL);
	return value->data[0].v_pointer;
}


void icp_config_colors_value_set_color (GValue* value, gpointer v_object) {
	icpConfigColorsColor* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_COLORS_TYPE_COLOR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_CONFIG_COLORS_TYPE_COLOR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_config_colors_color_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_colors_color_unref (old);
	}
}


void icp_config_colors_value_take_color (GValue* value, gpointer v_object) {
	icpConfigColorsColor* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_COLORS_TYPE_COLOR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_CONFIG_COLORS_TYPE_COLOR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_colors_color_unref (old);
	}
}


static void icp_config_colors_color_class_init (icpConfigColorsColorClass * klass) {
	icp_config_colors_color_parent_class = g_type_class_peek_parent (klass);
	ICP_CONFIG_COLORS_COLOR_CLASS (klass)->finalize = icp_config_colors_color_finalize;
	g_type_class_add_private (klass, sizeof (icpConfigColorsColorPrivate));
}


static void icp_config_colors_color_instance_init (icpConfigColorsColor * self) {
	self->priv = ICP_CONFIG_COLORS_COLOR_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void icp_config_colors_color_finalize (icpConfigColorsColor* obj) {
	icpConfigColorsColor * self;
	self = ICP_CONFIG_COLORS_COLOR (obj);
	_g_free0 (self->priv->foreground);
	_g_free0 (self->priv->background);
}


GType icp_config_colors_color_get_type (void) {
	static volatile gsize icp_config_colors_color_type_id__volatile = 0;
	if (g_once_init_enter (&icp_config_colors_color_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_config_colors_value_color_init, icp_config_colors_value_color_free_value, icp_config_colors_value_color_copy_value, icp_config_colors_value_color_peek_pointer, "p", icp_config_colors_value_color_collect_value, "p", icp_config_colors_value_color_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpConfigColorsColorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_config_colors_color_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpConfigColorsColor), 0, (GInstanceInitFunc) icp_config_colors_color_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_config_colors_color_type_id;
		icp_config_colors_color_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpConfigColorsColor", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_config_colors_color_type_id__volatile, icp_config_colors_color_type_id);
	}
	return icp_config_colors_color_type_id__volatile;
}


gpointer icp_config_colors_color_ref (gpointer instance) {
	icpConfigColorsColor* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void icp_config_colors_color_unref (gpointer instance) {
	icpConfigColorsColor* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_CONFIG_COLORS_COLOR_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void icp_config_value_colors_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_config_value_colors_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_config_colors_unref (value->data[0].v_pointer);
	}
}


static void icp_config_value_colors_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_config_colors_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_config_value_colors_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_config_value_colors_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpConfigColors* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_config_colors_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_config_value_colors_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpConfigColors** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_config_colors_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* icp_config_param_spec_colors (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpConfigParamSpecColors* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_CONFIG_TYPE_COLORS), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer icp_config_value_get_colors (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_COLORS), NULL);
	return value->data[0].v_pointer;
}


void icp_config_value_set_colors (GValue* value, gpointer v_object) {
	icpConfigColors* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_COLORS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_CONFIG_TYPE_COLORS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_config_colors_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_colors_unref (old);
	}
}


void icp_config_value_take_colors (GValue* value, gpointer v_object) {
	icpConfigColors* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_COLORS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_CONFIG_TYPE_COLORS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_colors_unref (old);
	}
}


static void icp_config_colors_class_init (icpConfigColorsClass * klass) {
	icp_config_colors_parent_class = g_type_class_peek_parent (klass);
	ICP_CONFIG_COLORS_CLASS (klass)->finalize = icp_config_colors_finalize;
}


static void icp_config_colors_instance_init (icpConfigColors * self) {
	self->ref_count = 1;
}


static void icp_config_colors_finalize (icpConfigColors* obj) {
	icpConfigColors * self;
	self = ICP_CONFIG_COLORS (obj);
}


GType icp_config_colors_get_type (void) {
	static volatile gsize icp_config_colors_type_id__volatile = 0;
	if (g_once_init_enter (&icp_config_colors_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_config_value_colors_init, icp_config_value_colors_free_value, icp_config_value_colors_copy_value, icp_config_value_colors_peek_pointer, "p", icp_config_value_colors_collect_value, "p", icp_config_value_colors_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpConfigColorsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_config_colors_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpConfigColors), 0, (GInstanceInitFunc) icp_config_colors_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_config_colors_type_id;
		icp_config_colors_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpConfigColors", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_config_colors_type_id__volatile, icp_config_colors_type_id);
	}
	return icp_config_colors_type_id__volatile;
}


gpointer icp_config_colors_ref (gpointer instance) {
	icpConfigColors* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void icp_config_colors_unref (gpointer instance) {
	icpConfigColors* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_CONFIG_COLORS_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


icpConfigLimits* icp_config_limits_new (void) {
	icpConfigLimits* self;
	self = g_slice_new0 (icpConfigLimits);
	icp_config_limits_instance_init (self);
	g_assert_not_reached ();
	return self;
}


static void icp_config_limits_instance_init (icpConfigLimits * self) {
}


void icp_config_limits_free (icpConfigLimits* self) {
	g_slice_free (icpConfigLimits, self);
}


icpConfigSwitches* icp_config_switches_new (void) {
	icpConfigSwitches* self;
	self = g_slice_new0 (icpConfigSwitches);
	icp_config_switches_instance_init (self);
	g_assert_not_reached ();
	return self;
}


static void icp_config_switches_instance_init (icpConfigSwitches * self) {
}


void icp_config_switches_free (icpConfigSwitches* self) {
	g_slice_free (icpConfigSwitches, self);
}


static icpConfigPunctuations* icp_config_punctuations_construct (GType object_type) {
	icpConfigPunctuations* self = (icpConfigPunctuations*) g_type_create_instance (object_type);
	return self;
}


static icpConfigPunctuations* icp_config_punctuations_new (void) {
	return icp_config_punctuations_construct (ICP_CONFIG_TYPE_PUNCTUATIONS);
}


void icp_config_punctuations_init (void) {
	GeeHashMap* _tmp0_;
	icp_config_punctuations_punctuations = (_tmp0_ = gee_hash_map_new (G_TYPE_INT, NULL, NULL, ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION, (GBoxedCopyFunc) icp_config_punctuations_full_punctuation_ref, icp_config_punctuations_full_punctuation_unref, NULL, NULL, NULL), _g_object_unref0 (icp_config_punctuations_punctuations), _tmp0_);
	icp_config_punctuations_set ((gint) '.', "", FALSE);
	icp_config_punctuations_set ((gint) ',', "", FALSE);
	icp_config_punctuations_set ((gint) '^', "", FALSE);
	icp_config_punctuations_set ((gint) '@', "", FALSE);
	icp_config_punctuations_set ((gint) '!', "", FALSE);
	icp_config_punctuations_set ((gint) '~', "", FALSE);
	icp_config_punctuations_set ((gint) '?', "", FALSE);
	icp_config_punctuations_set ((gint) '#', "", FALSE);
	icp_config_punctuations_set ((gint) '$', "", FALSE);
	icp_config_punctuations_set ((gint) '&', "", FALSE);
	icp_config_punctuations_set ((gint) '(', "", FALSE);
	icp_config_punctuations_set ((gint) ')', "", FALSE);
	icp_config_punctuations_set ((gint) '{', "", FALSE);
	icp_config_punctuations_set ((gint) '}', "", FALSE);
	icp_config_punctuations_set ((gint) '[', "", FALSE);
	icp_config_punctuations_set ((gint) ']', "", FALSE);
	icp_config_punctuations_set ((gint) ';', "", FALSE);
	icp_config_punctuations_set ((gint) ':', "", FALSE);
	icp_config_punctuations_set ((gint) '<', "", FALSE);
	icp_config_punctuations_set ((gint) '>', "", FALSE);
	icp_config_punctuations_set ((gint) '\\', "", FALSE);
	icp_config_punctuations_set ((gint) '\'', " ", FALSE);
	icp_config_punctuations_set ((gint) '\"', " ", FALSE);
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, (gssize) (-1));
	return result;
}


void icp_config_punctuations_set (gint half_char, const char* full_chars, gboolean only_after_chinese) {
	g_return_if_fail (full_chars != NULL);
	if (string_get_length (full_chars) == 0) {
		gee_abstract_map_unset (GEE_ABSTRACT_MAP (icp_config_punctuations_punctuations), GINT_TO_POINTER (half_char), NULL);
	} else {
		icpConfigPunctuationsFullPunctuation* _tmp0_;
		gee_abstract_map_set (GEE_ABSTRACT_MAP (icp_config_punctuations_punctuations), GINT_TO_POINTER (half_char), _tmp0_ = icp_config_punctuations_full_punctuation_new (full_chars, only_after_chinese));
		_icp_config_punctuations_full_punctuation_unref0 (_tmp0_);
	}
}


char* icp_config_punctuations_get (gint key, gboolean after_chinese) {
	char* result = NULL;
	gboolean _tmp0_ = FALSE;
	icpConfigPunctuationsFullPunctuation* _tmp4_;
	char* _tmp5_;
	if (!gee_abstract_map_has_key (GEE_ABSTRACT_MAP (icp_config_punctuations_punctuations), GINT_TO_POINTER (key))) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp1_ = FALSE;
		icpConfigPunctuationsFullPunctuation* _tmp2_;
		gboolean _tmp3_;
		if ((_tmp3_ = icp_config_punctuations_full_punctuation_get_only_after_chinese (_tmp2_ = (icpConfigPunctuationsFullPunctuation*) gee_abstract_map_get (GEE_ABSTRACT_MAP (icp_config_punctuations_punctuations), GINT_TO_POINTER (key))), _icp_config_punctuations_full_punctuation_unref0 (_tmp2_), _tmp3_)) {
			_tmp1_ = !after_chinese;
		} else {
			_tmp1_ = FALSE;
		}
		_tmp0_ = _tmp1_;
	}
	if (_tmp0_) {
		result = g_strdup_printf ("%c", key);
		return result;
	}
	result = (_tmp5_ = icp_config_punctuations_full_punctuation_get_full_char (_tmp4_ = (icpConfigPunctuationsFullPunctuation*) gee_abstract_map_get (GEE_ABSTRACT_MAP (icp_config_punctuations_punctuations), GINT_TO_POINTER (key))), _icp_config_punctuations_full_punctuation_unref0 (_tmp4_), _tmp5_);
	return result;
}


gboolean icp_config_punctuations_exists (gint key) {
	gboolean result = FALSE;
	result = gee_abstract_map_has_key (GEE_ABSTRACT_MAP (icp_config_punctuations_punctuations), GINT_TO_POINTER (key));
	return result;
}


icpConfigPunctuationsFullPunctuation* icp_config_punctuations_full_punctuation_construct (GType object_type, const char* full_chars, gboolean only_after_chinese) {
	icpConfigPunctuationsFullPunctuation* self = (icpConfigPunctuationsFullPunctuation*) g_type_create_instance (object_type);
	GeeArrayList* _tmp0_;
	g_return_val_if_fail (full_chars != NULL, NULL);
	self->priv->full_chars = (_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL), _g_object_unref0 (self->priv->full_chars), _tmp0_);
	{
		char** _tmp1_;
		char** s_collection;
		int s_collection_length1;
		int s_it;
		s_collection = _tmp1_ = g_strsplit (full_chars, " ", 0);
		s_collection_length1 = _vala_array_length (_tmp1_);
		for (s_it = 0; s_it < _vala_array_length (_tmp1_); s_it = s_it + 1) {
			char* s;
			s = g_strdup (s_collection[s_it]);
			{
				gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (self->priv->full_chars), s);
				_g_free0 (s);
			}
		}
		s_collection = (_vala_array_free (s_collection, s_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	icp_config_punctuations_full_punctuation_set_only_after_chinese (self, only_after_chinese);
	self->priv->index = 0;
	return self;
}


icpConfigPunctuationsFullPunctuation* icp_config_punctuations_full_punctuation_new (const char* full_chars, gboolean only_after_chinese) {
	return icp_config_punctuations_full_punctuation_construct (ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION, full_chars, only_after_chinese);
}


char* icp_config_punctuations_full_punctuation_get_full_char (icpConfigPunctuationsFullPunctuation* self) {
	char* result = NULL;
	char* r;
	g_return_val_if_fail (ICP_CONFIG_PUNCTUATIONS_IS_FULL_PUNCTUATION (self), NULL);
	r = (char*) gee_abstract_list_get (GEE_ABSTRACT_LIST (self->priv->full_chars), self->priv->index);
	if ((self->priv->index = self->priv->index + 1) == gee_collection_get_size (GEE_COLLECTION (self->priv->full_chars))) {
		self->priv->index = 0;
	}
	result = r;
	return result;
}


gboolean icp_config_punctuations_full_punctuation_get_only_after_chinese (icpConfigPunctuationsFullPunctuation* self) {
	gboolean result;
	g_return_val_if_fail (ICP_CONFIG_PUNCTUATIONS_IS_FULL_PUNCTUATION (self), FALSE);
	result = self->priv->_only_after_chinese;
	return result;
}


static void icp_config_punctuations_full_punctuation_set_only_after_chinese (icpConfigPunctuationsFullPunctuation* self, gboolean value) {
	g_return_if_fail (ICP_CONFIG_PUNCTUATIONS_IS_FULL_PUNCTUATION (self));
	self->priv->_only_after_chinese = value;
}


static void icp_config_punctuations_value_full_punctuation_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_config_punctuations_value_full_punctuation_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_config_punctuations_full_punctuation_unref (value->data[0].v_pointer);
	}
}


static void icp_config_punctuations_value_full_punctuation_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_config_punctuations_full_punctuation_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_config_punctuations_value_full_punctuation_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_config_punctuations_value_full_punctuation_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpConfigPunctuationsFullPunctuation* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_config_punctuations_full_punctuation_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_config_punctuations_value_full_punctuation_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpConfigPunctuationsFullPunctuation** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_config_punctuations_full_punctuation_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* icp_config_punctuations_param_spec_full_punctuation (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpConfigPunctuationsParamSpecFullPunctuation* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer icp_config_punctuations_value_get_full_punctuation (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION), NULL);
	return value->data[0].v_pointer;
}


void icp_config_punctuations_value_set_full_punctuation (GValue* value, gpointer v_object) {
	icpConfigPunctuationsFullPunctuation* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_config_punctuations_full_punctuation_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_punctuations_full_punctuation_unref (old);
	}
}


void icp_config_punctuations_value_take_full_punctuation (GValue* value, gpointer v_object) {
	icpConfigPunctuationsFullPunctuation* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_CONFIG_PUNCTUATIONS_TYPE_FULL_PUNCTUATION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_punctuations_full_punctuation_unref (old);
	}
}


static void icp_config_punctuations_full_punctuation_class_init (icpConfigPunctuationsFullPunctuationClass * klass) {
	icp_config_punctuations_full_punctuation_parent_class = g_type_class_peek_parent (klass);
	ICP_CONFIG_PUNCTUATIONS_FULL_PUNCTUATION_CLASS (klass)->finalize = icp_config_punctuations_full_punctuation_finalize;
	g_type_class_add_private (klass, sizeof (icpConfigPunctuationsFullPunctuationPrivate));
}


static void icp_config_punctuations_full_punctuation_instance_init (icpConfigPunctuationsFullPunctuation * self) {
	self->priv = ICP_CONFIG_PUNCTUATIONS_FULL_PUNCTUATION_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void icp_config_punctuations_full_punctuation_finalize (icpConfigPunctuationsFullPunctuation* obj) {
	icpConfigPunctuationsFullPunctuation * self;
	self = ICP_CONFIG_PUNCTUATIONS_FULL_PUNCTUATION (obj);
	_g_object_unref0 (self->priv->full_chars);
}


GType icp_config_punctuations_full_punctuation_get_type (void) {
	static volatile gsize icp_config_punctuations_full_punctuation_type_id__volatile = 0;
	if (g_once_init_enter (&icp_config_punctuations_full_punctuation_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_config_punctuations_value_full_punctuation_init, icp_config_punctuations_value_full_punctuation_free_value, icp_config_punctuations_value_full_punctuation_copy_value, icp_config_punctuations_value_full_punctuation_peek_pointer, "p", icp_config_punctuations_value_full_punctuation_collect_value, "p", icp_config_punctuations_value_full_punctuation_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpConfigPunctuationsFullPunctuationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_config_punctuations_full_punctuation_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpConfigPunctuationsFullPunctuation), 0, (GInstanceInitFunc) icp_config_punctuations_full_punctuation_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_config_punctuations_full_punctuation_type_id;
		icp_config_punctuations_full_punctuation_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpConfigPunctuationsFullPunctuation", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_config_punctuations_full_punctuation_type_id__volatile, icp_config_punctuations_full_punctuation_type_id);
	}
	return icp_config_punctuations_full_punctuation_type_id__volatile;
}


gpointer icp_config_punctuations_full_punctuation_ref (gpointer instance) {
	icpConfigPunctuationsFullPunctuation* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void icp_config_punctuations_full_punctuation_unref (gpointer instance) {
	icpConfigPunctuationsFullPunctuation* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_CONFIG_PUNCTUATIONS_FULL_PUNCTUATION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void icp_config_value_punctuations_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_config_value_punctuations_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_config_punctuations_unref (value->data[0].v_pointer);
	}
}


static void icp_config_value_punctuations_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_config_punctuations_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_config_value_punctuations_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_config_value_punctuations_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpConfigPunctuations* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_config_punctuations_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_config_value_punctuations_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpConfigPunctuations** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_config_punctuations_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* icp_config_param_spec_punctuations (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpConfigParamSpecPunctuations* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_CONFIG_TYPE_PUNCTUATIONS), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer icp_config_value_get_punctuations (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_PUNCTUATIONS), NULL);
	return value->data[0].v_pointer;
}


void icp_config_value_set_punctuations (GValue* value, gpointer v_object) {
	icpConfigPunctuations* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_PUNCTUATIONS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_CONFIG_TYPE_PUNCTUATIONS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_config_punctuations_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_punctuations_unref (old);
	}
}


void icp_config_value_take_punctuations (GValue* value, gpointer v_object) {
	icpConfigPunctuations* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_PUNCTUATIONS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_CONFIG_TYPE_PUNCTUATIONS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_punctuations_unref (old);
	}
}


static void icp_config_punctuations_class_init (icpConfigPunctuationsClass * klass) {
	icp_config_punctuations_parent_class = g_type_class_peek_parent (klass);
	ICP_CONFIG_PUNCTUATIONS_CLASS (klass)->finalize = icp_config_punctuations_finalize;
}


static void icp_config_punctuations_instance_init (icpConfigPunctuations * self) {
	self->ref_count = 1;
}


static void icp_config_punctuations_finalize (icpConfigPunctuations* obj) {
	icpConfigPunctuations * self;
	self = ICP_CONFIG_PUNCTUATIONS (obj);
}


GType icp_config_punctuations_get_type (void) {
	static volatile gsize icp_config_punctuations_type_id__volatile = 0;
	if (g_once_init_enter (&icp_config_punctuations_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_config_value_punctuations_init, icp_config_value_punctuations_free_value, icp_config_value_punctuations_copy_value, icp_config_value_punctuations_peek_pointer, "p", icp_config_value_punctuations_collect_value, "p", icp_config_value_punctuations_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpConfigPunctuationsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_config_punctuations_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpConfigPunctuations), 0, (GInstanceInitFunc) icp_config_punctuations_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_config_punctuations_type_id;
		icp_config_punctuations_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpConfigPunctuations", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_config_punctuations_type_id__volatile, icp_config_punctuations_type_id);
	}
	return icp_config_punctuations_type_id__volatile;
}


gpointer icp_config_punctuations_ref (gpointer instance) {
	icpConfigPunctuations* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void icp_config_punctuations_unref (gpointer instance) {
	icpConfigPunctuations* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_CONFIG_PUNCTUATIONS_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


icpConfigKey* icp_config_key_construct (GType object_type, guint key, guint state, const char* label) {
	icpConfigKey* self = (icpConfigKey*) g_type_create_instance (object_type);
	icp_config_key_set_key (self, key);
	icp_config_key_set_state (self, state);
	if (label == NULL) {
		char* _tmp0_;
		icp_config_key_set_label (self, _tmp0_ = g_strdup_printf ("%c", (gint) key));
		_g_free0 (_tmp0_);
	} else {
		icp_config_key_set_label (self, label);
	}
	return self;
}


icpConfigKey* icp_config_key_new (guint key, guint state, const char* label) {
	return icp_config_key_construct (ICP_CONFIG_TYPE_KEY, key, state, label);
}


guint icp_config_key_hash_func (icpConfigKey* a) {
	guint result = 0U;
	g_return_val_if_fail (ICP_CONFIG_IS_KEY (a), 0U);
	result = a->priv->_key | a->priv->_state;
	return result;
}


gboolean icp_config_key_equal_func (icpConfigKey* a, icpConfigKey* b) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (ICP_CONFIG_IS_KEY (a), FALSE);
	g_return_val_if_fail (ICP_CONFIG_IS_KEY (b), FALSE);
	if (a->priv->_key == b->priv->_key) {
		_tmp0_ = a->priv->_state == b->priv->_state;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


guint icp_config_key_get_key (icpConfigKey* self) {
	guint result;
	g_return_val_if_fail (ICP_CONFIG_IS_KEY (self), 0U);
	result = self->priv->_key;
	return result;
}


static void icp_config_key_set_key (icpConfigKey* self, guint value) {
	g_return_if_fail (ICP_CONFIG_IS_KEY (self));
	self->priv->_key = value;
}


guint icp_config_key_get_state (icpConfigKey* self) {
	guint result;
	g_return_val_if_fail (ICP_CONFIG_IS_KEY (self), 0U);
	result = self->priv->_state;
	return result;
}


static void icp_config_key_set_state (icpConfigKey* self, guint value) {
	g_return_if_fail (ICP_CONFIG_IS_KEY (self));
	self->priv->_state = value;
}


const char* icp_config_key_get_label (icpConfigKey* self) {
	const char* result;
	g_return_val_if_fail (ICP_CONFIG_IS_KEY (self), NULL);
	result = self->priv->_label;
	return result;
}


static void icp_config_key_set_label (icpConfigKey* self, const char* value) {
	char* _tmp0_;
	g_return_if_fail (ICP_CONFIG_IS_KEY (self));
	self->priv->_label = (_tmp0_ = g_strdup (value), _g_free0 (self->priv->_label), _tmp0_);
}


static void icp_config_value_key_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_config_value_key_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_config_key_unref (value->data[0].v_pointer);
	}
}


static void icp_config_value_key_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_config_key_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_config_value_key_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_config_value_key_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpConfigKey* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_config_key_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_config_value_key_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpConfigKey** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_config_key_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* icp_config_param_spec_key (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpConfigParamSpecKey* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_CONFIG_TYPE_KEY), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer icp_config_value_get_key (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_KEY), NULL);
	return value->data[0].v_pointer;
}


void icp_config_value_set_key (GValue* value, gpointer v_object) {
	icpConfigKey* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_KEY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_CONFIG_TYPE_KEY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_config_key_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_key_unref (old);
	}
}


void icp_config_value_take_key (GValue* value, gpointer v_object) {
	icpConfigKey* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_KEY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_CONFIG_TYPE_KEY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_key_unref (old);
	}
}


static void icp_config_key_class_init (icpConfigKeyClass * klass) {
	icp_config_key_parent_class = g_type_class_peek_parent (klass);
	ICP_CONFIG_KEY_CLASS (klass)->finalize = icp_config_key_finalize;
	g_type_class_add_private (klass, sizeof (icpConfigKeyPrivate));
}


static void icp_config_key_instance_init (icpConfigKey * self) {
	self->priv = ICP_CONFIG_KEY_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void icp_config_key_finalize (icpConfigKey* obj) {
	icpConfigKey * self;
	self = ICP_CONFIG_KEY (obj);
	_g_free0 (self->priv->_label);
}


GType icp_config_key_get_type (void) {
	static volatile gsize icp_config_key_type_id__volatile = 0;
	if (g_once_init_enter (&icp_config_key_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_config_value_key_init, icp_config_value_key_free_value, icp_config_value_key_copy_value, icp_config_value_key_peek_pointer, "p", icp_config_value_key_collect_value, "p", icp_config_value_key_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpConfigKeyClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_config_key_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpConfigKey), 0, (GInstanceInitFunc) icp_config_key_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_config_key_type_id;
		icp_config_key_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpConfigKey", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_config_key_type_id__volatile, icp_config_key_type_id);
	}
	return icp_config_key_type_id__volatile;
}


gpointer icp_config_key_ref (gpointer instance) {
	icpConfigKey* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void icp_config_key_unref (gpointer instance) {
	icpConfigKey* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_CONFIG_KEY_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static icpConfigKeyActions* icp_config_key_actions_construct (GType object_type) {
	icpConfigKeyActions* self = (icpConfigKeyActions*) g_type_create_instance (object_type);
	return self;
}


static icpConfigKeyActions* icp_config_key_actions_new (void) {
	return icp_config_key_actions_construct (ICP_CONFIG_TYPE_KEY_ACTIONS);
}


void icp_config_key_actions_init (void) {
	GeeHashMap* _tmp0_;
	icpConfigKey* _tmp1_;
	icpConfigKey* _tmp2_;
	icpConfigKey* _tmp3_;
	icpConfigKey* _tmp4_;
	icpConfigKey* _tmp5_;
	icpConfigKey* _tmp6_;
	icpConfigKey* _tmp7_;
	icpConfigKey* _tmp8_;
	icpConfigKey* _tmp9_;
	icpConfigKey* _tmp10_;
	icpConfigKey* _tmp11_;
	icpConfigKey* _tmp12_;
	icpConfigKey* _tmp13_;
	icpConfigKey* _tmp14_;
	icpConfigKey* _tmp15_;
	icpConfigKey* _tmp16_;
	icpConfigKey* _tmp17_;
	char* labels;
	icp_config_key_actions_key_actions = (_tmp0_ = gee_hash_map_new (ICP_CONFIG_TYPE_KEY, (GBoxedCopyFunc) icp_config_key_ref, icp_config_key_unref, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, (GHashFunc) icp_config_key_hash_func, (GEqualFunc) icp_config_key_equal_func, NULL), _g_object_unref0 (icp_config_key_actions_key_actions), _tmp0_);
	icp_config_key_actions_set (_tmp1_ = icp_config_key_new ((guint) IBUS_Tab, 0, NULL), "correct");
	_icp_config_key_unref0 (_tmp1_);
	icp_config_key_actions_set (_tmp2_ = icp_config_key_new ((guint) IBUS_BackSpace, 0, NULL), "back");
	_icp_config_key_unref0 (_tmp2_);
	icp_config_key_actions_set (_tmp3_ = icp_config_key_new ((guint) IBUS_space, 0, NULL), "commit");
	_icp_config_key_unref0 (_tmp3_);
	icp_config_key_actions_set (_tmp4_ = icp_config_key_new ((guint) IBUS_Escape, 0, NULL), "clear commit");
	_icp_config_key_unref0 (_tmp4_);
	icp_config_key_actions_set (_tmp5_ = icp_config_key_new ((guint) IBUS_Page_Down, 0, NULL), "pgdn");
	_icp_config_key_unref0 (_tmp5_);
	icp_config_key_actions_set (_tmp6_ = icp_config_key_new ((guint) 'h', 0, NULL), "pgdn");
	_icp_config_key_unref0 (_tmp6_);
	icp_config_key_actions_set (_tmp7_ = icp_config_key_new ((guint) ']', 0, NULL), "pgdn");
	_icp_config_key_unref0 (_tmp7_);
	icp_config_key_actions_set (_tmp8_ = icp_config_key_new ((guint) '=', 0, NULL), "pgdn");
	_icp_config_key_unref0 (_tmp8_);
	icp_config_key_actions_set (_tmp9_ = icp_config_key_new ((guint) IBUS_Page_Up, 0, NULL), "pgup");
	_icp_config_key_unref0 (_tmp9_);
	icp_config_key_actions_set (_tmp10_ = icp_config_key_new ((guint) 'g', 0, NULL), "pgup");
	_icp_config_key_unref0 (_tmp10_);
	icp_config_key_actions_set (_tmp11_ = icp_config_key_new ((guint) '[', 0, NULL), "pgup");
	_icp_config_key_unref0 (_tmp11_);
	icp_config_key_actions_set (_tmp12_ = icp_config_key_new ((guint) '-', 0, NULL), "pgup");
	_icp_config_key_unref0 (_tmp12_);
	icp_config_key_actions_set (_tmp13_ = icp_config_key_new ((guint) '\'', 0, NULL), "sep");
	_icp_config_key_unref0 (_tmp13_);
	icp_config_key_actions_set (_tmp14_ = icp_config_key_new ((guint) 'L', (guint) ((IBUS_RELEASE_MASK | IBUS_CONTROL_MASK) | IBUS_SHIFT_MASK), NULL), "trad simp");
	_icp_config_key_unref0 (_tmp14_);
	icp_config_key_actions_set (_tmp15_ = icp_config_key_new ((guint) IBUS_Shift_L, (guint) (IBUS_RELEASE_MASK | IBUS_SHIFT_MASK), NULL), "eng chs");
	_icp_config_key_unref0 (_tmp15_);
	icp_config_key_actions_set (_tmp16_ = icp_config_key_new ((guint) IBUS_Shift_R, (guint) (IBUS_RELEASE_MASK | IBUS_SHIFT_MASK), NULL), "online offline");
	_icp_config_key_unref0 (_tmp16_);
	icp_config_key_actions_set (_tmp17_ = icp_config_key_new ((guint) IBUS_Return, 0, NULL), "raw");
	_icp_config_key_unref0 (_tmp17_);
	labels = g_strdup ("jkl;asdf");
	{
		gint i;
		i = 0;
		{
			gboolean _tmp18_;
			_tmp18_ = TRUE;
			while (TRUE) {
				icpConfigKey* _tmp19_;
				char* _tmp20_;
				icpConfigKey* _tmp21_;
				char* _tmp22_;
				if (!_tmp18_) {
					i++;
				}
				_tmp18_ = FALSE;
				if (!(i < string_get_length (labels))) {
					break;
				}
				icp_config_key_actions_set (_tmp19_ = icp_config_key_new ((guint) g_utf8_get_char (g_utf8_offset_to_pointer (labels, i)), 0, NULL), _tmp20_ = g_strdup_printf ("cand:%d", i));
				_g_free0 (_tmp20_);
				_icp_config_key_unref0 (_tmp19_);
				icp_config_key_actions_set (_tmp21_ = icp_config_key_new ((guint) (i + '1'), 0, NULL), _tmp22_ = g_strdup_printf ("cand:%d", i));
				_g_free0 (_tmp22_);
				_icp_config_key_unref0 (_tmp21_);
			}
		}
	}
	_g_free0 (labels);
}


void icp_config_key_actions_set (icpConfigKey* key, const char* action) {
	g_return_if_fail (ICP_CONFIG_IS_KEY (key));
	g_return_if_fail (action != NULL);
	if (string_get_length (action) == 0) {
		gee_abstract_map_unset (GEE_ABSTRACT_MAP (icp_config_key_actions_key_actions), key, NULL);
	} else {
		gee_abstract_map_set (GEE_ABSTRACT_MAP (icp_config_key_actions_key_actions), key, action);
	}
}


char* icp_config_key_actions_get (icpConfigKey* key) {
	char* result = NULL;
	g_return_val_if_fail (ICP_CONFIG_IS_KEY (key), NULL);
	if (!gee_abstract_map_has_key (GEE_ABSTRACT_MAP (icp_config_key_actions_key_actions), key)) {
		result = g_strdup ("");
		return result;
	}
	result = (char*) gee_abstract_map_get (GEE_ABSTRACT_MAP (icp_config_key_actions_key_actions), key);
	return result;
}


static void icp_config_value_key_actions_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_config_value_key_actions_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_config_key_actions_unref (value->data[0].v_pointer);
	}
}


static void icp_config_value_key_actions_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_config_key_actions_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_config_value_key_actions_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_config_value_key_actions_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpConfigKeyActions* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_config_key_actions_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_config_value_key_actions_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpConfigKeyActions** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_config_key_actions_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* icp_config_param_spec_key_actions (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpConfigParamSpecKeyActions* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_CONFIG_TYPE_KEY_ACTIONS), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer icp_config_value_get_key_actions (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_KEY_ACTIONS), NULL);
	return value->data[0].v_pointer;
}


void icp_config_value_set_key_actions (GValue* value, gpointer v_object) {
	icpConfigKeyActions* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_KEY_ACTIONS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_CONFIG_TYPE_KEY_ACTIONS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_config_key_actions_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_key_actions_unref (old);
	}
}


void icp_config_value_take_key_actions (GValue* value, gpointer v_object) {
	icpConfigKeyActions* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_KEY_ACTIONS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_CONFIG_TYPE_KEY_ACTIONS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_key_actions_unref (old);
	}
}


static void icp_config_key_actions_class_init (icpConfigKeyActionsClass * klass) {
	icp_config_key_actions_parent_class = g_type_class_peek_parent (klass);
	ICP_CONFIG_KEY_ACTIONS_CLASS (klass)->finalize = icp_config_key_actions_finalize;
}


static void icp_config_key_actions_instance_init (icpConfigKeyActions * self) {
	self->ref_count = 1;
}


static void icp_config_key_actions_finalize (icpConfigKeyActions* obj) {
	icpConfigKeyActions * self;
	self = ICP_CONFIG_KEY_ACTIONS (obj);
}


GType icp_config_key_actions_get_type (void) {
	static volatile gsize icp_config_key_actions_type_id__volatile = 0;
	if (g_once_init_enter (&icp_config_key_actions_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_config_value_key_actions_init, icp_config_value_key_actions_free_value, icp_config_value_key_actions_copy_value, icp_config_value_key_actions_peek_pointer, "p", icp_config_value_key_actions_collect_value, "p", icp_config_value_key_actions_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpConfigKeyActionsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_config_key_actions_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpConfigKeyActions), 0, (GInstanceInitFunc) icp_config_key_actions_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_config_key_actions_type_id;
		icp_config_key_actions_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpConfigKeyActions", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_config_key_actions_type_id__volatile, icp_config_key_actions_type_id);
	}
	return icp_config_key_actions_type_id__volatile;
}


gpointer icp_config_key_actions_ref (gpointer instance) {
	icpConfigKeyActions* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void icp_config_key_actions_unref (gpointer instance) {
	icpConfigKeyActions* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_CONFIG_KEY_ACTIONS_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static icpConfigCandidateLabels* icp_config_candidate_labels_construct (GType object_type) {
	icpConfigCandidateLabels* self = (icpConfigCandidateLabels*) g_type_create_instance (object_type);
	return self;
}


static icpConfigCandidateLabels* icp_config_candidate_labels_new (void) {
	return icp_config_candidate_labels_construct (ICP_CONFIG_TYPE_CANDIDATE_LABELS);
}


void icp_config_candidate_labels_clear (void) {
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp1_;
	gee_abstract_collection_clear (GEE_ABSTRACT_COLLECTION (_tmp0_ = (GeeArrayList*) gee_abstract_list_get (GEE_ABSTRACT_LIST (icp_config_candidate_labels_labels), 0)));
	_g_object_unref0 (_tmp0_);
	gee_abstract_collection_clear (GEE_ABSTRACT_COLLECTION (_tmp1_ = (GeeArrayList*) gee_abstract_list_get (GEE_ABSTRACT_LIST (icp_config_candidate_labels_labels), 1)));
	_g_object_unref0 (_tmp1_);
}


void icp_config_candidate_labels_add (const char* label, const char* label_alternative) {
	GeeArrayList* _tmp0_;
	char* _tmp1_;
	GeeArrayList* _tmp3_;
	g_return_if_fail (label != NULL);
	gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (_tmp0_ = (GeeArrayList*) gee_abstract_list_get (GEE_ABSTRACT_LIST (icp_config_candidate_labels_labels), 0)), label);
	_g_object_unref0 (_tmp0_);
	_tmp1_ = g_strdup (label_alternative);
	if (_tmp1_ == NULL) {
		char* _tmp2_;
		_tmp1_ = (_tmp2_ = g_strdup (label), _g_free0 (_tmp1_), _tmp2_);
	}
	gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (_tmp3_ = (GeeArrayList*) gee_abstract_list_get (GEE_ABSTRACT_LIST (icp_config_candidate_labels_labels), 1)), _tmp1_);
	_g_object_unref0 (_tmp3_);
	_g_free0 (_tmp1_);
}


void icp_config_candidate_labels_set (gint index, const char* label, const char* label_alternative) {
	gboolean _tmp0_ = FALSE;
	if (index < 0) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = index >= icp_config_candidate_labels_get_size ();
	}
	if (_tmp0_) {
		return;
	}
	if (label != NULL) {
		GeeArrayList* _tmp1_;
		gee_abstract_list_set (GEE_ABSTRACT_LIST (_tmp1_ = (GeeArrayList*) gee_abstract_list_get (GEE_ABSTRACT_LIST (icp_config_candidate_labels_labels), 0)), index, label);
		_g_object_unref0 (_tmp1_);
	}
	if (label_alternative != NULL) {
		GeeArrayList* _tmp2_;
		gee_abstract_list_set (GEE_ABSTRACT_LIST (_tmp2_ = (GeeArrayList*) gee_abstract_list_get (GEE_ABSTRACT_LIST (icp_config_candidate_labels_labels), 1)), index, label_alternative);
		_g_object_unref0 (_tmp2_);
	}
}


char* icp_config_candidate_labels_get (gint index, gboolean use_alternative) {
	char* result = NULL;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_ = 0;
	GeeArrayList* _tmp2_;
	char* _tmp3_;
	if (index < 0) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = index >= icp_config_candidate_labels_get_size ();
	}
	if (_tmp0_) {
		result = g_strdup ("");
		return result;
	}
	if (use_alternative) {
		_tmp1_ = 1;
	} else {
		_tmp1_ = 0;
	}
	result = (_tmp3_ = (char*) gee_abstract_list_get (GEE_ABSTRACT_LIST (_tmp2_ = (GeeArrayList*) gee_abstract_list_get (GEE_ABSTRACT_LIST (icp_config_candidate_labels_labels), _tmp1_)), index), _g_object_unref0 (_tmp2_), _tmp3_);
	return result;
}


static char* string_slice (const char* self, glong start, glong end) {
	char* result = NULL;
	glong string_length;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	const char* start_string;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = string_get_length (self);
	if (start < 0) {
		start = string_length + start;
	}
	if (end < 0) {
		end = string_length + end;
	}
	if (start >= 0) {
		_tmp0_ = start <= string_length;
	} else {
		_tmp0_ = FALSE;
	}
	g_return_val_if_fail (_tmp0_, NULL);
	if (end >= 0) {
		_tmp1_ = end <= string_length;
	} else {
		_tmp1_ = FALSE;
	}
	g_return_val_if_fail (_tmp1_, NULL);
	g_return_val_if_fail (start <= end, NULL);
	start_string = g_utf8_offset_to_pointer (self, start);
	result = g_strndup (start_string, ((gchar*) g_utf8_offset_to_pointer (start_string, end - start)) - ((gchar*) start_string));
	return result;
}


void icp_config_candidate_labels_init (void) {
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	char* labels;
	icp_config_candidate_labels_labels = (_tmp0_ = gee_array_list_new (GEE_TYPE_ARRAY_LIST, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL), _g_object_unref0 (icp_config_candidate_labels_labels), _tmp0_);
	gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (icp_config_candidate_labels_labels), _tmp1_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL));
	_g_object_unref0 (_tmp1_);
	gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (icp_config_candidate_labels_labels), _tmp2_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL));
	_g_object_unref0 (_tmp2_);
	labels = g_strdup ("jkl;asdf");
	{
		gint i;
		i = 0;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				char* _tmp4_;
				char* _tmp5_;
				if (!_tmp3_) {
					i++;
				}
				_tmp3_ = FALSE;
				if (!(i < string_get_length (labels))) {
					break;
				}
				icp_config_candidate_labels_add (_tmp4_ = string_slice (labels, (glong) i, (glong) (i + 1)), _tmp5_ = g_strdup_printf ("%d", i + 1));
				_g_free0 (_tmp5_);
				_g_free0 (_tmp4_);
			}
		}
	}
	_g_free0 (labels);
}


gint icp_config_candidate_labels_get_size (void) {
	gint result;
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	gint _tmp3_;
	g_assert (gee_collection_get_size (GEE_COLLECTION (_tmp0_ = (GeeArrayList*) gee_abstract_list_get (GEE_ABSTRACT_LIST (icp_config_candidate_labels_labels), 0))) == gee_collection_get_size (GEE_COLLECTION (_tmp1_ = (GeeArrayList*) gee_abstract_list_get (GEE_ABSTRACT_LIST (icp_config_candidate_labels_labels), 1))));
	_g_object_unref0 (_tmp1_);
	_g_object_unref0 (_tmp0_);
	result = (_tmp3_ = gee_collection_get_size (GEE_COLLECTION (_tmp2_ = (GeeArrayList*) gee_abstract_list_get (GEE_ABSTRACT_LIST (icp_config_candidate_labels_labels), 0))), _g_object_unref0 (_tmp2_), _tmp3_);
	return result;
}


static void icp_config_value_candidate_labels_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_config_value_candidate_labels_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_config_candidate_labels_unref (value->data[0].v_pointer);
	}
}


static void icp_config_value_candidate_labels_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_config_candidate_labels_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_config_value_candidate_labels_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_config_value_candidate_labels_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpConfigCandidateLabels* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_config_candidate_labels_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_config_value_candidate_labels_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpConfigCandidateLabels** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_config_candidate_labels_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* icp_config_param_spec_candidate_labels (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpConfigParamSpecCandidateLabels* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_CONFIG_TYPE_CANDIDATE_LABELS), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer icp_config_value_get_candidate_labels (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_CANDIDATE_LABELS), NULL);
	return value->data[0].v_pointer;
}


void icp_config_value_set_candidate_labels (GValue* value, gpointer v_object) {
	icpConfigCandidateLabels* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_CANDIDATE_LABELS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_CONFIG_TYPE_CANDIDATE_LABELS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_config_candidate_labels_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_candidate_labels_unref (old);
	}
}


void icp_config_value_take_candidate_labels (GValue* value, gpointer v_object) {
	icpConfigCandidateLabels* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_CONFIG_TYPE_CANDIDATE_LABELS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_CONFIG_TYPE_CANDIDATE_LABELS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_candidate_labels_unref (old);
	}
}


static void icp_config_candidate_labels_class_init (icpConfigCandidateLabelsClass * klass) {
	icp_config_candidate_labels_parent_class = g_type_class_peek_parent (klass);
	ICP_CONFIG_CANDIDATE_LABELS_CLASS (klass)->finalize = icp_config_candidate_labels_finalize;
}


static void icp_config_candidate_labels_instance_init (icpConfigCandidateLabels * self) {
	self->ref_count = 1;
}


static void icp_config_candidate_labels_finalize (icpConfigCandidateLabels* obj) {
	icpConfigCandidateLabels * self;
	self = ICP_CONFIG_CANDIDATE_LABELS (obj);
}


GType icp_config_candidate_labels_get_type (void) {
	static volatile gsize icp_config_candidate_labels_type_id__volatile = 0;
	if (g_once_init_enter (&icp_config_candidate_labels_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_config_value_candidate_labels_init, icp_config_value_candidate_labels_free_value, icp_config_value_candidate_labels_copy_value, icp_config_value_candidate_labels_peek_pointer, "p", icp_config_value_candidate_labels_collect_value, "p", icp_config_value_candidate_labels_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpConfigCandidateLabelsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_config_candidate_labels_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpConfigCandidateLabels), 0, (GInstanceInitFunc) icp_config_candidate_labels_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_config_candidate_labels_type_id;
		icp_config_candidate_labels_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpConfigCandidateLabels", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_config_candidate_labels_type_id__volatile, icp_config_candidate_labels_type_id);
	}
	return icp_config_candidate_labels_type_id__volatile;
}


gpointer icp_config_candidate_labels_ref (gpointer instance) {
	icpConfigCandidateLabels* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void icp_config_candidate_labels_unref (gpointer instance) {
	icpConfigCandidateLabels* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_CONFIG_CANDIDATE_LABELS_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void icp_value_config_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_value_config_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_config_unref (value->data[0].v_pointer);
	}
}


static void icp_value_config_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_config_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_value_config_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_value_config_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpConfig* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_config_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_value_config_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpConfig** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_config_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* icp_param_spec_config (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpParamSpecConfig* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_TYPE_CONFIG), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer icp_value_get_config (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_CONFIG), NULL);
	return value->data[0].v_pointer;
}


void icp_value_set_config (GValue* value, gpointer v_object) {
	icpConfig* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_CONFIG));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_TYPE_CONFIG));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_config_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_unref (old);
	}
}


void icp_value_take_config (GValue* value, gpointer v_object) {
	icpConfig* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_CONFIG));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_TYPE_CONFIG));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_config_unref (old);
	}
}


static void icp_config_class_init (icpConfigClass * klass) {
	icp_config_parent_class = g_type_class_peek_parent (klass);
	ICP_CONFIG_CLASS (klass)->finalize = icp_config_finalize;
}


static void icp_config_instance_init (icpConfig * self) {
	self->ref_count = 1;
}


static void icp_config_finalize (icpConfig* obj) {
	icpConfig * self;
	self = ICP_CONFIG (obj);
}


GType icp_config_get_type (void) {
	static volatile gsize icp_config_type_id__volatile = 0;
	if (g_once_init_enter (&icp_config_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_value_config_init, icp_value_config_free_value, icp_value_config_copy_value, icp_value_config_peek_pointer, "p", icp_value_config_collect_value, "p", icp_value_config_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpConfigClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_config_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpConfig), 0, (GInstanceInitFunc) icp_config_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_config_type_id;
		icp_config_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpConfig", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_config_type_id__volatile, icp_config_type_id);
	}
	return icp_config_type_id__volatile;
}


gpointer icp_config_ref (gpointer instance) {
	icpConfig* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void icp_config_unref (gpointer instance) {
	icpConfig* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_CONFIG_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




