/* ibus-engine.c generated by valac 0.10.4, the Vala compiler
 * generated from ibus-engine.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <ibus.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>


#define ICP_TYPE_IBUS_BINDING (icp_ibus_binding_get_type ())
#define ICP_IBUS_BINDING(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_TYPE_IBUS_BINDING, icpIBusBinding))
#define ICP_IBUS_BINDING_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_TYPE_IBUS_BINDING, icpIBusBindingClass))
#define ICP_IS_IBUS_BINDING(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_TYPE_IBUS_BINDING))
#define ICP_IS_IBUS_BINDING_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_TYPE_IBUS_BINDING))
#define ICP_IBUS_BINDING_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_TYPE_IBUS_BINDING, icpIBusBindingClass))

typedef struct _icpIBusBinding icpIBusBinding;
typedef struct _icpIBusBindingClass icpIBusBindingClass;
typedef struct _icpIBusBindingPrivate icpIBusBindingPrivate;

#define ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE (icp_ibus_binding_cloud_pinyin_engine_get_type ())
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE, icpIBusBindingCloudPinyinEngine))
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE, icpIBusBindingCloudPinyinEngineClass))
#define ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE))
#define ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE))
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE, icpIBusBindingCloudPinyinEngineClass))

typedef struct _icpIBusBindingCloudPinyinEngine icpIBusBindingCloudPinyinEngine;
typedef struct _icpIBusBindingCloudPinyinEngineClass icpIBusBindingCloudPinyinEngineClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
typedef struct _icpIBusBindingCloudPinyinEnginePrivate icpIBusBindingCloudPinyinEnginePrivate;

#define ICP_PINYIN_TYPE_SEQUENCE (icp_pinyin_sequence_get_type ())
#define ICP_PINYIN_SEQUENCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_PINYIN_TYPE_SEQUENCE, icpPinyinSequence))
#define ICP_PINYIN_SEQUENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_PINYIN_TYPE_SEQUENCE, icpPinyinSequenceClass))
#define ICP_PINYIN_IS_SEQUENCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_PINYIN_TYPE_SEQUENCE))
#define ICP_PINYIN_IS_SEQUENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_PINYIN_TYPE_SEQUENCE))
#define ICP_PINYIN_SEQUENCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_PINYIN_TYPE_SEQUENCE, icpPinyinSequenceClass))

typedef struct _icpPinyinSequence icpPinyinSequence;
typedef struct _icpPinyinSequenceClass icpPinyinSequenceClass;

#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT (icp_ibus_binding_cloud_pinyin_engine_pending_segment_get_type ())
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_PENDING_SEGMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT, icpIBusBindingCloudPinyinEnginePendingSegment))
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_PENDING_SEGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT, icpIBusBindingCloudPinyinEnginePendingSegmentClass))
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_IS_PENDING_SEGMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT))
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_IS_PENDING_SEGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT))
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_PENDING_SEGMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT, icpIBusBindingCloudPinyinEnginePendingSegmentClass))

typedef struct _icpIBusBindingCloudPinyinEnginePendingSegment icpIBusBindingCloudPinyinEnginePendingSegment;
typedef struct _icpIBusBindingCloudPinyinEnginePendingSegmentClass icpIBusBindingCloudPinyinEnginePendingSegmentClass;

#define ICP_PINYIN_TYPE_ID (icp_pinyin_id_get_type ())
#define ICP_PINYIN_ID(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_PINYIN_TYPE_ID, icpPinyinId))
#define ICP_PINYIN_ID_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_PINYIN_TYPE_ID, icpPinyinIdClass))
#define ICP_PINYIN_IS_ID(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_PINYIN_TYPE_ID))
#define ICP_PINYIN_IS_ID_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_PINYIN_TYPE_ID))
#define ICP_PINYIN_ID_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_PINYIN_TYPE_ID, icpPinyinIdClass))

typedef struct _icpPinyinId icpPinyinId;
typedef struct _icpPinyinIdClass icpPinyinIdClass;
#define _icp_pinyin_sequence_unref0(var) ((var == NULL) ? NULL : (var = (icp_pinyin_sequence_unref (var), NULL)))
#define _g_source_unref0(var) ((var == NULL) ? NULL : (var = (g_source_unref (var), NULL)))
typedef struct _icpIBusBindingCloudPinyinEnginePendingSegmentPrivate icpIBusBindingCloudPinyinEnginePendingSegmentPrivate;
#define _icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0(var) ((var == NULL) ? NULL : (var = (icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref (var), NULL)))
#define _icp_pinyin_id_unref0(var) ((var == NULL) ? NULL : (var = (icp_pinyin_id_unref (var), NULL)))

#define ICP_CONFIG_TYPE_KEY (icp_config_key_get_type ())
#define ICP_CONFIG_KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_CONFIG_TYPE_KEY, icpConfigKey))
#define ICP_CONFIG_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_CONFIG_TYPE_KEY, icpConfigKeyClass))
#define ICP_CONFIG_IS_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_CONFIG_TYPE_KEY))
#define ICP_CONFIG_IS_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_CONFIG_TYPE_KEY))
#define ICP_CONFIG_KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_CONFIG_TYPE_KEY, icpConfigKeyClass))

typedef struct _icpConfigKey icpConfigKey;
typedef struct _icpConfigKeyClass icpConfigKeyClass;
#define _icp_config_key_unref0(var) ((var == NULL) ? NULL : (var = (icp_config_key_unref (var), NULL)))

#define ICP_CONFIG_COLORS_TYPE_COLOR (icp_config_colors_color_get_type ())
#define ICP_CONFIG_COLORS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_CONFIG_COLORS_TYPE_COLOR, icpConfigColorsColor))
#define ICP_CONFIG_COLORS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_CONFIG_COLORS_TYPE_COLOR, icpConfigColorsColorClass))
#define ICP_CONFIG_COLORS_IS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_CONFIG_COLORS_TYPE_COLOR))
#define ICP_CONFIG_COLORS_IS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_CONFIG_COLORS_TYPE_COLOR))
#define ICP_CONFIG_COLORS_COLOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_CONFIG_COLORS_TYPE_COLOR, icpConfigColorsColorClass))

typedef struct _icpConfigColorsColor icpConfigColorsColor;
typedef struct _icpConfigColorsColorClass icpConfigColorsColorClass;

#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT (icp_ibus_binding_cloud_pinyin_engine_color_segment_get_type ())
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_COLOR_SEGMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT, icpIBusBindingCloudPinyinEngineColorSegment))
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_COLOR_SEGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT, icpIBusBindingCloudPinyinEngineColorSegmentClass))
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_IS_COLOR_SEGMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT))
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_IS_COLOR_SEGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT))
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_COLOR_SEGMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT, icpIBusBindingCloudPinyinEngineColorSegmentClass))

typedef struct _icpIBusBindingCloudPinyinEngineColorSegment icpIBusBindingCloudPinyinEngineColorSegment;
typedef struct _icpIBusBindingCloudPinyinEngineColorSegmentClass icpIBusBindingCloudPinyinEngineColorSegmentClass;
#define _icp_ibus_binding_cloud_pinyin_engine_color_segment_unref0(var) ((var == NULL) ? NULL : (var = (icp_ibus_binding_cloud_pinyin_engine_color_segment_unref (var), NULL)))
typedef struct _icpIBusBindingCloudPinyinEngineParamSpecPendingSegment icpIBusBindingCloudPinyinEngineParamSpecPendingSegment;
typedef struct _icpIBusBindingCloudPinyinEngineColorSegmentPrivate icpIBusBindingCloudPinyinEngineColorSegmentPrivate;
#define _icp_config_colors_color_unref0(var) ((var == NULL) ? NULL : (var = (icp_config_colors_color_unref (var), NULL)))
typedef struct _icpIBusBindingCloudPinyinEngineParamSpecColorSegment icpIBusBindingCloudPinyinEngineParamSpecColorSegment;
typedef struct _icpParamSpecIBusBinding icpParamSpecIBusBinding;

struct _icpIBusBinding {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpIBusBindingPrivate * priv;
};

struct _icpIBusBindingClass {
	GTypeClass parent_class;
	void (*finalize) (icpIBusBinding *self);
};

struct _icpIBusBindingCloudPinyinEngine {
	IBusEngine parent_instance;
	icpIBusBindingCloudPinyinEnginePrivate * priv;
};

struct _icpIBusBindingCloudPinyinEngineClass {
	IBusEngineClass parent_class;
};

struct _icpIBusBindingCloudPinyinEnginePrivate {
	char* raw_buffer;
	icpPinyinSequence* pinyin_buffer;
	char* pinyin_buffer_preedit;
	gboolean chinese_mode;
	gboolean correction_mode;
	gboolean offline_mode;
	gboolean traditional_mode;
	gboolean last_is_chinese;
	GeeLinkedList* pending_segment_list;
	gboolean prerequest_done;
	IBusLookupTable* table;
	gint cloud_candidate_count;
	gboolean table_visible;
	guint page_index;
	IBusProperty* chinese_mode_icon;
	IBusProperty* traditional_conversion_icon;
	IBusProperty* status_icon;
	IBusProperty* tools_icon;
	IBusProperty* tools_status_item;
	IBusProperty* tools_scel_import_item;
	IBusPropList* tools_menu_list;
	IBusPropList* panel_prop_list;
	GSource* waiting_animation_timer;
	gboolean last_chinese_mode;
	gboolean last_traditional_mode;
	gboolean last_offline_mode;
	gint waiting_index;
	gint waiting_index_acc;
	gint waiting_subindex;
	gboolean last_prerequest_done;
	gboolean inited;
	gint prerequest_retry;
	char* last_prerequest_pinyins;
	guint last_state;
	GeeArrayList* user_pinyins;
	char* user_phrase;
	char* last_pinyin_buffer_string;
	gboolean last_correction_mode;
};

struct _icpIBusBindingCloudPinyinEnginePendingSegment {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpIBusBindingCloudPinyinEnginePendingSegmentPrivate * priv;
	gboolean done;
	char* content;
	icpPinyinSequence* pinyins;
	gint retry;
};

struct _icpIBusBindingCloudPinyinEnginePendingSegmentClass {
	GTypeClass parent_class;
	void (*finalize) (icpIBusBindingCloudPinyinEnginePendingSegment *self);
};

struct _icpIBusBindingCloudPinyinEngineParamSpecPendingSegment {
	GParamSpec parent_instance;
};

struct _icpIBusBindingCloudPinyinEngineColorSegment {
	GTypeInstance parent_instance;
	volatile int ref_count;
	icpIBusBindingCloudPinyinEngineColorSegmentPrivate * priv;
};

struct _icpIBusBindingCloudPinyinEngineColorSegmentClass {
	GTypeClass parent_class;
	void (*finalize) (icpIBusBindingCloudPinyinEngineColorSegment *self);
};

struct _icpIBusBindingCloudPinyinEngineColorSegmentPrivate {
	icpConfigColorsColor* color;
	guint start;
	gint end;
};

struct _icpIBusBindingCloudPinyinEngineParamSpecColorSegment {
	GParamSpec parent_instance;
};

struct _icpParamSpecIBusBinding {
	GParamSpec parent_instance;
};


static IBusEngineDesc* icp_ibus_binding_engine;
static IBusEngineDesc* icp_ibus_binding_engine = NULL;
static IBusComponent* icp_ibus_binding_component;
static IBusComponent* icp_ibus_binding_component = NULL;
static IBusBus* icp_ibus_binding_bus;
static IBusBus* icp_ibus_binding_bus = NULL;
static IBusFactory* icp_ibus_binding_factory;
static IBusFactory* icp_ibus_binding_factory = NULL;
extern icpIBusBindingCloudPinyinEngine* icp_ibus_binding_active_engine;
icpIBusBindingCloudPinyinEngine* icp_ibus_binding_active_engine = NULL;
extern gboolean icp_config_commandline_options_launched_by_ibus;
extern GMainLoop* icp_main_loop;
extern gboolean icp_config_switches_default_chinese_mode;
extern gboolean icp_config_switches_default_traditional_mode;
extern gboolean icp_config_switches_default_offline_mode;
extern gint icp_config_limits_prerequest_retry_limit;
static gint icp_dbus_binding_last_cloud_length;
extern double icp_config_timeouts_request;
extern double icp_config_timeouts_prerequest;
extern gboolean icp_config_switches_background_request;
extern double icp_config_timeouts_selection;
extern gboolean icp_config_switches_double_pinyin;
extern gboolean icp_config_switches_show_pinyin_auxiliary;
extern gboolean icp_config_switches_show_raw_in_auxiliary;
extern icpConfigColorsColor* icp_config_colors_buffer_pinyin;
extern icpConfigColorsColor* icp_config_colors_buffer_raw;
extern icpConfigColorsColor* icp_config_colors_preedit_remote;
extern icpConfigColorsColor* icp_config_colors_preedit_local;
extern icpConfigColorsColor* icp_config_colors_preedit_fixed;
extern icpConfigColorsColor* icp_config_colors_preedit_correcting;
extern gboolean icp_config_switches_always_show_candidates;
extern gint icp_config_limits_cloud_candidates_limit;
extern gint icp_config_limits_db_query_limit;
extern icpConfigColorsColor* icp_config_colors_candidate_remote;
extern icpConfigColorsColor* icp_config_colors_candidate_local;
extern gint icp_config_limits_request_retry_limit;
static gpointer icp_ibus_binding_cloud_pinyin_engine_pending_segment_parent_class = NULL;
static gpointer icp_ibus_binding_cloud_pinyin_engine_color_segment_parent_class = NULL;
static gpointer icp_ibus_binding_cloud_pinyin_engine_parent_class = NULL;
static gpointer icp_ibus_binding_parent_class = NULL;

gpointer icp_ibus_binding_ref (gpointer instance);
void icp_ibus_binding_unref (gpointer instance);
GParamSpec* icp_param_spec_ibus_binding (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_value_set_ibus_binding (GValue* value, gpointer v_object);
void icp_value_take_ibus_binding (GValue* value, gpointer v_object);
gpointer icp_value_get_ibus_binding (const GValue* value);
GType icp_ibus_binding_get_type (void) G_GNUC_CONST;
enum  {
	ICP_IBUS_BINDING_DUMMY_PROPERTY
};
GType icp_ibus_binding_cloud_pinyin_engine_get_type (void) G_GNUC_CONST;
#define ICP_IBUS_BINDING_key_state_filter ((guint) ((((((((IBUS_SHIFT_MASK | IBUS_LOCK_MASK) | IBUS_CONTROL_MASK) | IBUS_MOD1_MASK) | IBUS_MOD4_MASK) | IBUS_MOD5_MASK) | IBUS_SUPER_MASK) | IBUS_RELEASE_MASK) | IBUS_META_MASK))
void icp_ibus_binding_init (void);
#define ICP_CONFIG_version "0.8.0.20101124"
#define ICP_CONFIG_prefix_path "/usr"
const char* icp_config_get_global_data_path (void);
char* icp_ibus_binding_get_component_xml (void);
void icp_ibus_binding_register (void);
icpIBusBinding* icp_ibus_binding_new (void);
icpIBusBinding* icp_ibus_binding_construct (GType object_type);
gpointer icp_pinyin_sequence_ref (gpointer instance);
void icp_pinyin_sequence_unref (gpointer instance);
GParamSpec* icp_pinyin_param_spec_sequence (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_pinyin_value_set_sequence (GValue* value, gpointer v_object);
void icp_pinyin_value_take_sequence (GValue* value, gpointer v_object);
gpointer icp_pinyin_value_get_sequence (const GValue* value);
GType icp_pinyin_sequence_get_type (void) G_GNUC_CONST;
static gpointer icp_ibus_binding_cloud_pinyin_engine_pending_segment_ref (gpointer instance);
static void icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref (gpointer instance);
static GParamSpec* icp_ibus_binding_cloud_pinyin_engine_param_spec_pending_segment (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void icp_ibus_binding_cloud_pinyin_engine_value_set_pending_segment (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void icp_ibus_binding_cloud_pinyin_engine_value_take_pending_segment (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer icp_ibus_binding_cloud_pinyin_engine_value_get_pending_segment (const GValue* value) G_GNUC_UNUSED;
static GType icp_ibus_binding_cloud_pinyin_engine_pending_segment_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
gpointer icp_pinyin_id_ref (gpointer instance);
void icp_pinyin_id_unref (gpointer instance);
GParamSpec* icp_pinyin_param_spec_id (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_pinyin_value_set_id (GValue* value, gpointer v_object);
void icp_pinyin_value_take_id (GValue* value, gpointer v_object);
gpointer icp_pinyin_value_get_id (const GValue* value);
GType icp_pinyin_id_get_type (void) G_GNUC_CONST;
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE, icpIBusBindingCloudPinyinEnginePrivate))
enum  {
	ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_DUMMY_PROPERTY
};
static void icp_ibus_binding_cloud_pinyin_engine_start_requesting (icpIBusBindingCloudPinyinEngine* self);
static gboolean _lambda0_ (icpIBusBindingCloudPinyinEngine* self);
static void icp_ibus_binding_cloud_pinyin_engine_send_prerequest (icpIBusBindingCloudPinyinEngine* self);
static void icp_ibus_binding_cloud_pinyin_engine_update_preedit (icpIBusBindingCloudPinyinEngine* self);
static gboolean icp_ibus_binding_cloud_pinyin_engine_process_pending_list (icpIBusBindingCloudPinyinEngine* self);
gint icp_lua_binding_get_engine_speed_rank (gint low, gint high);
static void icp_ibus_binding_cloud_pinyin_engine_stop_requesting (icpIBusBindingCloudPinyinEngine* self);
static gboolean __lambda0__gsource_func (gpointer self);
static void icp_ibus_binding_cloud_pinyin_engine_force_commit_pending_list (icpIBusBindingCloudPinyinEngine* self);
static void icp_ibus_binding_cloud_pinyin_engine_update_candidates (icpIBusBindingCloudPinyinEngine* self);
static void icp_ibus_binding_cloud_pinyin_engine_init (icpIBusBindingCloudPinyinEngine* self);
icpPinyinSequence* icp_pinyin_sequence_new (const char* pinyins);
icpPinyinSequence* icp_pinyin_sequence_construct (GType object_type, const char* pinyins);
gint icp_lua_binding_get_engine_count (void);
gint icp_config_candidate_labels_get_size (void);
static void icp_ibus_binding_cloud_pinyin_engine_update_properties (icpIBusBindingCloudPinyinEngine* self);
static void icp_ibus_binding_cloud_pinyin_engine_commit_buffer (icpIBusBindingCloudPinyinEngine* self);
char* icp_dbus_binding_convert (icpPinyinSequence* pinyins, gboolean offline_mode, gint* cloud_length);
char* icp_dbus_binding_query (const char* pinyins);
char* icp_pinyin_sequence_to_string (icpPinyinSequence* self, gint start, gint len);
void icp_lua_binding_start_requests (const char* pinyins, double timeout, gboolean* done);
gint icp_pinyin_sequence_get_size (icpPinyinSequence* self);
icpPinyinId* icp_pinyin_sequence_get_id (icpPinyinSequence* self, gint index);
gint icp_pinyin_id_get_vowel (icpPinyinId* self);
static void icp_ibus_binding_cloud_pinyin_engine_real_reset (IBusEngine* base);
static void icp_ibus_binding_cloud_pinyin_engine_real_enable (IBusEngine* base);
static void icp_ibus_binding_cloud_pinyin_engine_real_disable (IBusEngine* base);
static void icp_ibus_binding_cloud_pinyin_engine_real_focus_in (IBusEngine* base);
static void icp_ibus_binding_cloud_pinyin_engine_real_focus_out (IBusEngine* base);
static void icp_ibus_binding_cloud_pinyin_engine_real_property_activate (IBusEngine* base, const char* prop_name, guint prop_state);
static void icp_ibus_binding_cloud_pinyin_engine_switch_offline_mode (icpIBusBindingCloudPinyinEngine* self);
const char* icp_config_get_program_scel_import (void);
void icp_lua_binding_show_engine_speed_rank (void);
static gboolean icp_ibus_binding_cloud_pinyin_engine_is_pending_segment_list_empty (icpIBusBindingCloudPinyinEngine* self);
void icp_ibus_binding_cloud_pinyin_engine_commit (icpIBusBindingCloudPinyinEngine* self, const char* content);
void icp_frontend_clear_selection (void);
static icpIBusBindingCloudPinyinEnginePendingSegment* icp_ibus_binding_cloud_pinyin_engine_pending_segment_new_from_content (const char* content);
static icpIBusBindingCloudPinyinEnginePendingSegment* icp_ibus_binding_cloud_pinyin_engine_pending_segment_construct_from_content (GType object_type, const char* content);
static void icp_ibus_binding_cloud_pinyin_engine_commit_pinyins (icpIBusBindingCloudPinyinEngine* self, icpPinyinSequence* pinyins);
static icpIBusBindingCloudPinyinEnginePendingSegment* icp_ibus_binding_cloud_pinyin_engine_pending_segment_new_from_pinyins (icpPinyinSequence* pinyins);
static icpIBusBindingCloudPinyinEnginePendingSegment* icp_ibus_binding_cloud_pinyin_engine_pending_segment_construct_from_pinyins (GType object_type, icpPinyinSequence* pinyins);
void icp_frontend_notify (const char* title, const char* content, const char* icon);
static void icp_ibus_binding_cloud_pinyin_engine_clear_buffer (icpIBusBindingCloudPinyinEngine* self);
static void icp_ibus_binding_cloud_pinyin_engine_user_phrase_clear (icpIBusBindingCloudPinyinEngine* self);
void icp_pinyin_sequence_clear (icpPinyinSequence* self);
static gboolean icp_ibus_binding_cloud_pinyin_engine_real_process_key_event (IBusEngine* base, guint keyval, guint keycode, guint state);
gpointer icp_config_key_ref (gpointer instance);
void icp_config_key_unref (gpointer instance);
GParamSpec* icp_config_param_spec_key (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_config_value_set_key (GValue* value, gpointer v_object);
void icp_config_value_take_key (GValue* value, gpointer v_object);
gpointer icp_config_value_get_key (const GValue* value);
GType icp_config_key_get_type (void) G_GNUC_CONST;
char* icp_config_key_actions_get (icpConfigKey* key);
icpConfigKey* icp_config_key_new (guint key, guint state, const char* label);
icpConfigKey* icp_config_key_construct (GType object_type, guint key, guint state, const char* label);
void icp_lua_binding_do_string (const char* script);
guint64 icp_frontend_get_current_time (void);
guint64 icp_frontend_get_clipboard_update_time (void);
char* icp_frontend_get_selection (void);
gboolean icp_database_reverse_convert (const char* content, icpPinyinSequence** pinyins);
char* icp_pinyin_sequence_to_double_pinyin_string (icpPinyinSequence* self, gint start, gint len);
gboolean icp_pinyin_double_pinyin_is_valid_key (guint key);
void icp_pinyin_double_pinyin_convert (const char* double_pinyins, icpPinyinSequence** sequence);
gboolean icp_config_punctuations_exists (gint key);
char* icp_config_punctuations_get (gint key, gboolean after_chinese);
icpPinyinSequence* icp_pinyin_sequence_new_copy (icpPinyinSequence* that, gint start, gint len);
icpPinyinSequence* icp_pinyin_sequence_construct_copy (GType object_type, icpPinyinSequence* that, gint start, gint len);
static void icp_ibus_binding_cloud_pinyin_engine_real_page_up (IBusEngine* base);
static void icp_ibus_binding_cloud_pinyin_engine_real_page_down (IBusEngine* base);
static void icp_ibus_binding_cloud_pinyin_engine_real_candidate_clicked (IBusEngine* base, guint index, guint button, guint state);
icpPinyinSequence* icp_pinyin_sequence_new_ids (GeeArrayList* ids);
icpPinyinSequence* icp_pinyin_sequence_construct_ids (GType object_type, GeeArrayList* ids);
void icp_database_insert (const char* phrase, icpPinyinSequence* sequence, double base_freq, double freq_increase, gboolean lookup_first);
gboolean icp_dbus_binding_set_response (const char* pinyins, const char* content, gint priority);
gpointer icp_config_colors_color_ref (gpointer instance);
void icp_config_colors_color_unref (gpointer instance);
GParamSpec* icp_config_colors_param_spec_color (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void icp_config_colors_value_set_color (GValue* value, gpointer v_object);
void icp_config_colors_value_take_color (GValue* value, gpointer v_object);
gpointer icp_config_colors_value_get_color (const GValue* value);
GType icp_config_colors_color_get_type (void) G_GNUC_CONST;
void icp_config_colors_color_apply (icpConfigColorsColor* self, IBusText* text, guint start, gint end);
static gpointer icp_ibus_binding_cloud_pinyin_engine_color_segment_ref (gpointer instance);
static void icp_ibus_binding_cloud_pinyin_engine_color_segment_unref (gpointer instance);
static GParamSpec* icp_ibus_binding_cloud_pinyin_engine_param_spec_color_segment (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void icp_ibus_binding_cloud_pinyin_engine_value_set_color_segment (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void icp_ibus_binding_cloud_pinyin_engine_value_take_color_segment (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer icp_ibus_binding_cloud_pinyin_engine_value_get_color_segment (const GValue* value) G_GNUC_UNUSED;
static GType icp_ibus_binding_cloud_pinyin_engine_color_segment_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static icpIBusBindingCloudPinyinEngineColorSegment* icp_ibus_binding_cloud_pinyin_engine_color_segment_new (icpConfigColorsColor* color, guint start, gint end);
static icpIBusBindingCloudPinyinEngineColorSegment* icp_ibus_binding_cloud_pinyin_engine_color_segment_construct (GType object_type, icpConfigColorsColor* color, guint start, gint end);
static void icp_ibus_binding_cloud_pinyin_engine_color_segment_apply (icpIBusBindingCloudPinyinEngineColorSegment* self, IBusText* text);
void icp_database_query (icpPinyinSequence* pinyins, GeeArrayList* candidates, gint limit, double phrase_adjust);
char* icp_config_candidate_labels_get (gint index, gboolean use_alternative);
icpIBusBindingCloudPinyinEngine* icp_ibus_binding_cloud_pinyin_engine_new (void);
icpIBusBindingCloudPinyinEngine* icp_ibus_binding_cloud_pinyin_engine_construct (GType object_type);
enum  {
	ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_PENDING_SEGMENT_DUMMY_PROPERTY
};
static icpIBusBindingCloudPinyinEnginePendingSegment* icp_ibus_binding_cloud_pinyin_engine_pending_segment_new (void);
static icpIBusBindingCloudPinyinEnginePendingSegment* icp_ibus_binding_cloud_pinyin_engine_pending_segment_construct (GType object_type);
static void icp_ibus_binding_cloud_pinyin_engine_pending_segment_finalize (icpIBusBindingCloudPinyinEnginePendingSegment* obj);
#define ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_COLOR_SEGMENT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT, icpIBusBindingCloudPinyinEngineColorSegmentPrivate))
enum  {
	ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_COLOR_SEGMENT_DUMMY_PROPERTY
};
static void icp_ibus_binding_cloud_pinyin_engine_color_segment_finalize (icpIBusBindingCloudPinyinEngineColorSegment* obj);
static void icp_ibus_binding_cloud_pinyin_engine_finalize (GObject* obj);
static void icp_ibus_binding_finalize (icpIBusBinding* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);
static int _vala_strcmp0 (const char * str1, const char * str2);



void icp_ibus_binding_init (void) {
	IBusComponent* _tmp0_;
	char* _tmp1_;
	IBusEngineDesc* _tmp2_;
	icp_ibus_binding_component = (_tmp0_ = g_object_ref_sink (ibus_component_new ("org.freedesktop.IBus.cloudpinyin", "Cloud Pinyin", ICP_CONFIG_version, "GPL", "WU Jun <quark@lihdd.net>", "http://code.google.com/p/ibus-cloud-pinyin/", ICP_CONFIG_prefix_path "/lib/ibus/ibus-engine-cloud-pinyin --ibus --replace", "ibus-cloud-pinyin")), _g_object_unref0 (icp_ibus_binding_component), _tmp0_);
	icp_ibus_binding_engine = (_tmp2_ = g_object_ref_sink (ibus_engine_desc_new ("cloud-pinyin", "Cloud Pinyin", "A client of cloud pinyin IME on ibus", "zh_CN", "GPL", "WU Jun <quark@lihdd.net>", _tmp1_ = g_strconcat (icp_config_get_global_data_path (), "/icons/ibus-cloud-pinyin.png", NULL), "us")), _g_object_unref0 (icp_ibus_binding_engine), _tmp2_);
	_g_free0 (_tmp1_);
	ibus_component_add_engine (icp_ibus_binding_component, icp_ibus_binding_engine);
}


char* icp_ibus_binding_get_component_xml (void) {
	char* result = NULL;
	GString* builder;
	builder = g_string_new ("");
	g_string_append (builder, "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");
	ibus_component_output (icp_ibus_binding_component, builder, 0);
	result = g_strdup (builder->str);
	_g_string_free0 (builder);
	return result;
}


void icp_ibus_binding_register (void) {
	IBusBus* _tmp0_;
	IBusFactory* _tmp1_;
	icp_ibus_binding_bus = (_tmp0_ = g_object_ref_sink (ibus_bus_new ()), _g_object_unref0 (icp_ibus_binding_bus), _tmp0_);
	if (icp_config_commandline_options_launched_by_ibus) {
		ibus_bus_request_name (icp_ibus_binding_bus, "org.freedesktop.IBus.cloudpinyin", (guint) 0);
	} else {
		ibus_bus_register_component (icp_ibus_binding_bus, icp_ibus_binding_component);
	}
	icp_ibus_binding_factory = (_tmp1_ = g_object_ref_sink (ibus_factory_new (ibus_bus_get_connection (icp_ibus_binding_bus))), _g_object_unref0 (icp_ibus_binding_factory), _tmp1_);
	ibus_factory_add_engine (icp_ibus_binding_factory, "cloud-pinyin", ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE);
}


icpIBusBinding* icp_ibus_binding_construct (GType object_type) {
	icpIBusBinding* self = (icpIBusBinding*) g_type_create_instance (object_type);
	return self;
}


icpIBusBinding* icp_ibus_binding_new (void) {
	return icp_ibus_binding_construct (ICP_TYPE_IBUS_BINDING);
}


static gboolean _lambda0_ (icpIBusBindingCloudPinyinEngine* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	char* icon_path;
	if (self->priv->prerequest_done) {
		_tmp0_ = !self->priv->last_prerequest_done;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		icp_ibus_binding_cloud_pinyin_engine_send_prerequest (self);
		self->priv->last_prerequest_done = self->priv->prerequest_done;
		icp_ibus_binding_cloud_pinyin_engine_update_preedit (self);
	}
	if (icp_ibus_binding_cloud_pinyin_engine_process_pending_list (self)) {
		icp_ibus_binding_cloud_pinyin_engine_update_preedit (self);
	}
	icon_path = NULL;
	if (self->priv->waiting_subindex > 1) {
		gboolean _tmp1_ = FALSE;
		self->priv->waiting_subindex = 0;
		if (gee_collection_get_size (GEE_COLLECTION (self->priv->pending_segment_list)) == 0) {
			_tmp1_ = self->priv->prerequest_done;
		} else {
			_tmp1_ = FALSE;
		}
		if (_tmp1_) {
			char* _tmp2_;
			icon_path = (_tmp2_ = g_strdup_printf ("%s/icons/idle-%d.png", icp_config_get_global_data_path (), icp_lua_binding_get_engine_speed_rank (0, 4)), _g_free0 (icon_path), _tmp2_);
		} else {
			gboolean _tmp3_ = FALSE;
			char* _tmp4_;
			self->priv->waiting_index = self->priv->waiting_index + self->priv->waiting_index_acc;
			if (self->priv->waiting_index == 3) {
				_tmp3_ = TRUE;
			} else {
				_tmp3_ = self->priv->waiting_index == 0;
			}
			if (_tmp3_) {
				self->priv->waiting_index_acc = -self->priv->waiting_index_acc;
			}
			icon_path = (_tmp4_ = g_strdup_printf ("%s/icons/waiting-%d.png", icp_config_get_global_data_path (), self->priv->waiting_index), _g_free0 (icon_path), _tmp4_);
		}
		if (_vala_strcmp0 (icon_path, self->priv->status_icon->icon) != 0) {
			ibus_property_set_icon (self->priv->status_icon, icon_path);
			ibus_engine_update_property (IBUS_ENGINE (self), self->priv->status_icon);
		}
	} else {
		self->priv->waiting_subindex++;
	}
	if (self->priv->offline_mode) {
		icp_ibus_binding_cloud_pinyin_engine_stop_requesting (self);
	}
	result = TRUE;
	_g_free0 (icon_path);
	return result;
}


static gboolean __lambda0__gsource_func (gpointer self) {
	gboolean result;
	result = _lambda0_ (self);
	return result;
}


static void icp_ibus_binding_cloud_pinyin_engine_start_requesting (icpIBusBindingCloudPinyinEngine* self) {
	GSource* _tmp0_;
	g_return_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self));
	if (self->priv->waiting_animation_timer != NULL) {
		return;
	}
	self->priv->waiting_animation_timer = (_tmp0_ = g_timeout_source_new ((guint) 64), _g_source_unref0 (self->priv->waiting_animation_timer), _tmp0_);
	g_source_set_callback (self->priv->waiting_animation_timer, __lambda0__gsource_func, g_object_ref (self), g_object_unref);
	g_source_attach (self->priv->waiting_animation_timer, g_main_loop_get_context (icp_main_loop));
}


static void icp_ibus_binding_cloud_pinyin_engine_stop_requesting (icpIBusBindingCloudPinyinEngine* self) {
	GSource* _tmp0_;
	g_return_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self));
	icp_ibus_binding_cloud_pinyin_engine_force_commit_pending_list (self);
	if (self->priv->waiting_animation_timer == NULL) {
		return;
	}
	if (!g_source_is_destroyed (self->priv->waiting_animation_timer)) {
		g_source_destroy (self->priv->waiting_animation_timer);
	}
	self->priv->waiting_animation_timer = (_tmp0_ = NULL, _g_source_unref0 (self->priv->waiting_animation_timer), _tmp0_);
	icp_ibus_binding_cloud_pinyin_engine_update_preedit (self);
	icp_ibus_binding_cloud_pinyin_engine_update_candidates (self);
}


static void icp_ibus_binding_cloud_pinyin_engine_init (icpIBusBindingCloudPinyinEngine* self) {
	char* _tmp0_;
	char* _tmp1_;
	icpPinyinSequence* _tmp2_;
	GSource* _tmp3_;
	IBusLookupTable* _tmp4_;
	GeeArrayList* candidates;
	GeeArrayList* _tmp7_;
	char* _tmp8_;
	GeeLinkedList* _tmp9_;
	g_return_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self));
	self->priv->raw_buffer = (_tmp0_ = g_strdup (""), _g_free0 (self->priv->raw_buffer), _tmp0_);
	self->priv->last_pinyin_buffer_string = (_tmp1_ = g_strdup (""), _g_free0 (self->priv->last_pinyin_buffer_string), _tmp1_);
	self->priv->pinyin_buffer = (_tmp2_ = icp_pinyin_sequence_new (self->priv->raw_buffer), _icp_pinyin_sequence_unref0 (self->priv->pinyin_buffer), _tmp2_);
	self->priv->table_visible = FALSE;
	self->priv->chinese_mode = icp_config_switches_default_chinese_mode;
	self->priv->traditional_mode = icp_config_switches_default_traditional_mode;
	self->priv->offline_mode = icp_config_switches_default_offline_mode;
	if (icp_lua_binding_get_engine_count () == 0) {
		self->priv->offline_mode = TRUE;
	}
	self->priv->correction_mode = FALSE;
	ibus_prop_list_append (self->priv->tools_menu_list, self->priv->tools_status_item);
	ibus_prop_list_append (self->priv->tools_menu_list, self->priv->tools_scel_import_item);
	ibus_property_set_sub_props (self->priv->tools_icon, self->priv->tools_menu_list);
	ibus_prop_list_append (self->priv->panel_prop_list, self->priv->chinese_mode_icon);
	ibus_prop_list_append (self->priv->panel_prop_list, self->priv->traditional_conversion_icon);
	ibus_prop_list_append (self->priv->panel_prop_list, self->priv->status_icon);
	ibus_prop_list_append (self->priv->panel_prop_list, self->priv->tools_icon);
	self->priv->waiting_animation_timer = (_tmp3_ = NULL, _g_source_unref0 (self->priv->waiting_animation_timer), _tmp3_);
	self->priv->prerequest_retry = icp_config_limits_prerequest_retry_limit;
	self->priv->page_index = (guint) 0;
	self->priv->table = (_tmp4_ = g_object_ref_sink (ibus_lookup_table_new ((guint) icp_config_candidate_labels_get_size (), (guint) 0, FALSE, FALSE)), _g_object_unref0 (self->priv->table), _tmp4_);
	candidates = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp5_;
			_tmp5_ = TRUE;
			while (TRUE) {
				IBusText* _tmp6_;
				if (!_tmp5_) {
					i++;
				}
				_tmp5_ = FALSE;
				if (!(i < icp_config_candidate_labels_get_size ())) {
					break;
				}
				ibus_lookup_table_append_label (self->priv->table, _tmp6_ = g_object_ref_sink (ibus_text_new_from_string (".")));
				_g_object_unref0 (_tmp6_);
			}
		}
	}
	self->priv->user_pinyins = (_tmp7_ = gee_array_list_new (ICP_PINYIN_TYPE_ID, (GBoxedCopyFunc) icp_pinyin_id_ref, icp_pinyin_id_unref, NULL), _g_object_unref0 (self->priv->user_pinyins), _tmp7_);
	self->priv->user_phrase = (_tmp8_ = g_strdup (""), _g_free0 (self->priv->user_phrase), _tmp8_);
	self->priv->pending_segment_list = (_tmp9_ = gee_linked_list_new (ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT, (GBoxedCopyFunc) icp_ibus_binding_cloud_pinyin_engine_pending_segment_ref, icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref, NULL), _g_object_unref0 (self->priv->pending_segment_list), _tmp9_);
	self->priv->prerequest_done = TRUE;
	self->priv->last_prerequest_done = FALSE;
	if (!self->priv->offline_mode) {
		icp_ibus_binding_cloud_pinyin_engine_start_requesting (self);
	}
	self->priv->inited = TRUE;
	icp_ibus_binding_cloud_pinyin_engine_update_properties (self);
	_g_object_unref0 (candidates);
}


static void icp_ibus_binding_cloud_pinyin_engine_force_commit_pending_list (icpIBusBindingCloudPinyinEngine* self) {
	g_return_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self));
	icp_ibus_binding_cloud_pinyin_engine_commit_buffer (self);
	{
		GeeIterator* _seg_it;
		_seg_it = gee_abstract_collection_iterator (GEE_ABSTRACT_COLLECTION (self->priv->pending_segment_list));
		while (TRUE) {
			icpIBusBindingCloudPinyinEnginePendingSegment* seg;
			if (!gee_iterator_next (_seg_it)) {
				break;
			}
			seg = (icpIBusBindingCloudPinyinEnginePendingSegment*) gee_iterator_get (_seg_it);
			if (seg->content != NULL) {
				IBusText* _tmp0_;
				char* _tmp1_;
				ibus_engine_commit_text (IBUS_ENGINE (self), _tmp0_ = g_object_ref_sink (ibus_text_new_from_string (seg->content)));
				_g_object_unref0 (_tmp0_);
				seg->content = (_tmp1_ = NULL, _g_free0 (seg->content), _tmp1_);
			} else {
				if (seg->pinyins != NULL) {
					char* content;
					IBusText* _tmp2_;
					icpPinyinSequence* _tmp3_;
					content = icp_dbus_binding_convert (seg->pinyins, self->priv->offline_mode, &icp_dbus_binding_last_cloud_length);
					ibus_engine_commit_text (IBUS_ENGINE (self), _tmp2_ = g_object_ref_sink (ibus_text_new_from_string (content)));
					_g_object_unref0 (_tmp2_);
					seg->pinyins = (_tmp3_ = NULL, _icp_pinyin_sequence_unref0 (seg->pinyins), _tmp3_);
					_g_free0 (content);
				}
			}
			_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (seg);
		}
		_g_object_unref0 (_seg_it);
	}
}


static gboolean icp_ibus_binding_cloud_pinyin_engine_process_pending_list (icpIBusBindingCloudPinyinEngine* self) {
	gboolean result = FALSE;
	gboolean preedit_should_update;
	gboolean first_items;
	gint committed_item_count;
	g_return_val_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self), FALSE);
	preedit_should_update = FALSE;
	first_items = TRUE;
	committed_item_count = 0;
	{
		GeeIterator* _seg_it;
		_seg_it = gee_abstract_collection_iterator (GEE_ABSTRACT_COLLECTION (self->priv->pending_segment_list));
		while (TRUE) {
			icpIBusBindingCloudPinyinEnginePendingSegment* seg;
			gboolean _tmp0_ = FALSE;
			gboolean _tmp5_ = FALSE;
			if (!gee_iterator_next (_seg_it)) {
				break;
			}
			seg = (icpIBusBindingCloudPinyinEnginePendingSegment*) gee_iterator_get (_seg_it);
			if (!seg->done) {
				first_items = FALSE;
				_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (seg);
				continue;
			}
			if (seg->content == NULL) {
				_tmp0_ = seg->pinyins != NULL;
			} else {
				_tmp0_ = FALSE;
			}
			if (_tmp0_) {
				char* _tmp1_;
				char* _tmp2_;
				char* content;
				content = (_tmp2_ = icp_dbus_binding_query (_tmp1_ = icp_pinyin_sequence_to_string (seg->pinyins, 0, -1)), _g_free0 (_tmp1_), _tmp2_);
				if (strlen (content) > 0) {
					char* _tmp3_;
					icpPinyinSequence* _tmp4_;
					seg->content = (_tmp3_ = g_strdup (content), _g_free0 (seg->content), _tmp3_);
					seg->pinyins = (_tmp4_ = NULL, _icp_pinyin_sequence_unref0 (seg->pinyins), _tmp4_);
				}
				_g_free0 (content);
			}
			if (seg->pinyins != NULL) {
				_tmp5_ = seg->retry <= 0;
			} else {
				_tmp5_ = FALSE;
			}
			if (_tmp5_) {
				char* _tmp6_;
				icpPinyinSequence* _tmp7_;
				seg->content = (_tmp6_ = icp_dbus_binding_convert (seg->pinyins, self->priv->offline_mode, &icp_dbus_binding_last_cloud_length), _g_free0 (seg->content), _tmp6_);
				seg->pinyins = (_tmp7_ = NULL, _icp_pinyin_sequence_unref0 (seg->pinyins), _tmp7_);
			}
			if (seg->pinyins == NULL) {
				if (first_items) {
					committed_item_count++;
				}
				_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (seg);
				continue;
			}
			first_items = FALSE;
			if (seg->content == NULL) {
				char* _tmp8_;
				preedit_should_update = TRUE;
				seg->done = FALSE;
				icp_lua_binding_start_requests (_tmp8_ = icp_pinyin_sequence_to_string (seg->pinyins, 0, -1), icp_config_timeouts_request, &seg->done);
				_g_free0 (_tmp8_);
				seg->retry--;
			}
			_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (seg);
		}
		_g_object_unref0 (_seg_it);
	}
	if (committed_item_count > 0) {
		GeeLinkedList* head_segs;
		preedit_should_update = TRUE;
		head_segs = gee_linked_list_new (ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT, (GBoxedCopyFunc) icp_ibus_binding_cloud_pinyin_engine_pending_segment_ref, icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref, NULL);
		gee_deque_drain_head (GEE_DEQUE (self->priv->pending_segment_list), GEE_COLLECTION (head_segs), committed_item_count);
		{
			GeeIterator* _seg_it;
			_seg_it = gee_abstract_collection_iterator (GEE_ABSTRACT_COLLECTION (head_segs));
			while (TRUE) {
				icpIBusBindingCloudPinyinEnginePendingSegment* seg;
				if (!gee_iterator_next (_seg_it)) {
					break;
				}
				seg = (icpIBusBindingCloudPinyinEnginePendingSegment*) gee_iterator_get (_seg_it);
				if (seg->content != NULL) {
					IBusText* _tmp9_;
					ibus_engine_commit_text (IBUS_ENGINE (self), _tmp9_ = g_object_ref_sink (ibus_text_new_from_string (seg->content)));
					_g_object_unref0 (_tmp9_);
				}
				_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (seg);
			}
			_g_object_unref0 (_seg_it);
		}
		_g_object_unref0 (head_segs);
	}
	result = preedit_should_update;
	return result;
}


static void icp_ibus_binding_cloud_pinyin_engine_send_prerequest (icpIBusBindingCloudPinyinEngine* self) {
	gboolean _tmp0_ = FALSE;
	gint i;
	icpPinyinId* _tmp1_;
	gboolean _tmp2_;
	char* pinyins;
	gboolean _tmp4_ = FALSE;
	char* _tmp5_;
	gboolean _tmp6_;
	g_return_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self));
	if (self->priv->offline_mode) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = !self->priv->prerequest_done;
	}
	if (_tmp0_) {
		return;
	}
	i = icp_pinyin_sequence_get_size (self->priv->pinyin_buffer) - 1;
	if ((_tmp2_ = icp_pinyin_id_get_vowel (_tmp1_ = icp_pinyin_sequence_get_id (self->priv->pinyin_buffer, i)) <= 0, _icp_pinyin_id_unref0 (_tmp1_), _tmp2_)) {
		i--;
	}
	if (i <= 0) {
		return;
	}
	pinyins = icp_pinyin_sequence_to_string (self->priv->pinyin_buffer, 0, i + 1);
	if (_vala_strcmp0 (self->priv->last_prerequest_pinyins, pinyins) != 0) {
		char* _tmp3_;
		self->priv->prerequest_retry = icp_config_limits_prerequest_retry_limit;
		self->priv->last_prerequest_pinyins = (_tmp3_ = g_strdup (pinyins), _g_free0 (self->priv->last_prerequest_pinyins), _tmp3_);
	}
	if ((_tmp6_ = _vala_strcmp0 (_tmp5_ = icp_dbus_binding_query (pinyins), "") == 0, _g_free0 (_tmp5_), _tmp6_)) {
		_tmp4_ = self->priv->prerequest_retry > 0;
	} else {
		_tmp4_ = FALSE;
	}
	if (_tmp4_) {
		self->priv->prerequest_retry--;
		self->priv->prerequest_done = FALSE;
		icp_lua_binding_start_requests (pinyins, icp_config_timeouts_prerequest, &self->priv->prerequest_done);
		icp_ibus_binding_cloud_pinyin_engine_start_requesting (self);
	}
	_g_free0 (pinyins);
}


static void icp_ibus_binding_cloud_pinyin_engine_real_reset (IBusEngine* base) {
	icpIBusBindingCloudPinyinEngine * self;
	self = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE (base);
}


static void icp_ibus_binding_cloud_pinyin_engine_real_enable (IBusEngine* base) {
	icpIBusBindingCloudPinyinEngine * self;
	self = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE (base);
	IBUS_ENGINE (self)->enabled = TRUE;
	if (!self->priv->inited) {
		icp_ibus_binding_cloud_pinyin_engine_init (self);
	}
	icp_ibus_binding_cloud_pinyin_engine_update_properties (self);
}


static void icp_ibus_binding_cloud_pinyin_engine_real_disable (IBusEngine* base) {
	icpIBusBindingCloudPinyinEngine * self;
	self = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE (base);
	IBUS_ENGINE (self)->enabled = FALSE;
	fprintf (stdout, "called disable\n");
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void icp_ibus_binding_cloud_pinyin_engine_real_focus_in (IBusEngine* base) {
	icpIBusBindingCloudPinyinEngine * self;
	char* _tmp0_;
	icpIBusBindingCloudPinyinEngine* _tmp1_;
	self = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE (base);
	IBUS_ENGINE (self)->has_focus = TRUE;
	if (!self->priv->inited) {
		icp_ibus_binding_cloud_pinyin_engine_init (self);
	}
	ibus_engine_register_properties (IBUS_ENGINE (self), self->priv->panel_prop_list);
	icp_ibus_binding_cloud_pinyin_engine_update_properties (self);
	icp_ibus_binding_cloud_pinyin_engine_update_preedit (self);
	self->priv->last_pinyin_buffer_string = (_tmp0_ = g_strdup ("."), _g_free0 (self->priv->last_pinyin_buffer_string), _tmp0_);
	icp_ibus_binding_cloud_pinyin_engine_update_candidates (self);
	icp_ibus_binding_active_engine = (_tmp1_ = _g_object_ref0 (self), _g_object_unref0 (icp_ibus_binding_active_engine), _tmp1_);
}


static void icp_ibus_binding_cloud_pinyin_engine_real_focus_out (IBusEngine* base) {
	icpIBusBindingCloudPinyinEngine * self;
	icpIBusBindingCloudPinyinEngine* _tmp0_;
	self = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE (base);
	icp_ibus_binding_cloud_pinyin_engine_force_commit_pending_list (self);
	IBUS_ENGINE (self)->has_focus = FALSE;
	icp_ibus_binding_active_engine = (_tmp0_ = NULL, _g_object_unref0 (icp_ibus_binding_active_engine), _tmp0_);
}


static void icp_ibus_binding_cloud_pinyin_engine_real_property_activate (IBusEngine* base, const char* prop_name, guint prop_state) {
	icpIBusBindingCloudPinyinEngine * self;
	const char* _tmp2_;
	GQuark _tmp3_;
	static GQuark _tmp3__label0 = 0;
	static GQuark _tmp3__label1 = 0;
	static GQuark _tmp3__label2 = 0;
	static GQuark _tmp3__label3 = 0;
	static GQuark _tmp3__label4 = 0;
	GError * _inner_error_ = NULL;
	self = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE (base);
	g_return_if_fail (prop_name != NULL);
	_tmp2_ = prop_name;
	_tmp3_ = (NULL == _tmp2_) ? 0 : g_quark_from_string (_tmp2_);
	if (_tmp3_ == ((0 != _tmp3__label0) ? _tmp3__label0 : (_tmp3__label0 = g_quark_from_static_string ("mode"))))
	switch (0) {
		default:
		{
			self->priv->chinese_mode = !self->priv->chinese_mode;
			break;
		}
	} else if (_tmp3_ == ((0 != _tmp3__label1) ? _tmp3__label1 : (_tmp3__label1 = g_quark_from_static_string ("trad"))))
	switch (0) {
		default:
		{
			self->priv->traditional_mode = !self->priv->traditional_mode;
			break;
		}
	} else if (_tmp3_ == ((0 != _tmp3__label2) ? _tmp3__label2 : (_tmp3__label2 = g_quark_from_static_string ("status"))))
	switch (0) {
		default:
		{
			icp_ibus_binding_cloud_pinyin_engine_switch_offline_mode (self);
			break;
		}
	} else if (_tmp3_ == ((0 != _tmp3__label3) ? _tmp3__label3 : (_tmp3__label3 = g_quark_from_static_string ("tools_scel_import"))))
	switch (0) {
		default:
		{
			gint argv_length1;
			gint _argv_size_;
			char** _tmp1_;
			char** _tmp0_ = NULL;
			char** argv;
			GPid pid = 0;
			argv = (_tmp1_ = (_tmp0_ = g_new0 (char*, 1 + 1), _tmp0_[0] = g_strdup (icp_config_get_program_scel_import ()), _tmp0_), argv_length1 = 1, _argv_size_ = argv_length1, _tmp1_);
			g_spawn_async (NULL, argv, NULL, 0, NULL, NULL, &pid, &_inner_error_);
			if (_inner_error_ != NULL) {
				argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			g_spawn_close_pid (pid);
			argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
			break;
		}
	} else if (_tmp3_ == ((0 != _tmp3__label4) ? _tmp3__label4 : (_tmp3__label4 = g_quark_from_static_string ("tools_status"))))
	switch (0) {
		default:
		{
			icp_lua_binding_show_engine_speed_rank ();
			break;
		}
	}
	icp_ibus_binding_cloud_pinyin_engine_update_properties (self);
}


static gboolean icp_ibus_binding_cloud_pinyin_engine_is_pending_segment_list_empty (icpIBusBindingCloudPinyinEngine* self) {
	gboolean result = FALSE;
	gboolean r;
	g_return_val_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self), FALSE);
	r = TRUE;
	{
		GeeIterator* _seg_it;
		_seg_it = gee_abstract_collection_iterator (GEE_ABSTRACT_COLLECTION (self->priv->pending_segment_list));
		while (TRUE) {
			icpIBusBindingCloudPinyinEnginePendingSegment* seg;
			gboolean _tmp0_ = FALSE;
			if (!gee_iterator_next (_seg_it)) {
				break;
			}
			seg = (icpIBusBindingCloudPinyinEnginePendingSegment*) gee_iterator_get (_seg_it);
			if (seg->content != NULL) {
				_tmp0_ = TRUE;
			} else {
				_tmp0_ = seg->pinyins != NULL;
			}
			if (_tmp0_) {
				r = FALSE;
				_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (seg);
				break;
			}
			_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (seg);
		}
		_g_object_unref0 (_seg_it);
	}
	result = r;
	return result;
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, (gssize) (-1));
	return result;
}


void icp_ibus_binding_cloud_pinyin_engine_commit (icpIBusBindingCloudPinyinEngine* self, const char* content) {
	g_return_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self));
	g_return_if_fail (content != NULL);
	if (string_get_length (content) > 0) {
		icp_frontend_clear_selection ();
		if (icp_ibus_binding_cloud_pinyin_engine_is_pending_segment_list_empty (self)) {
			IBusText* _tmp0_;
			ibus_engine_commit_text (IBUS_ENGINE (self), _tmp0_ = g_object_ref_sink (ibus_text_new_from_string (content)));
			_g_object_unref0 (_tmp0_);
		} else {
			icpIBusBindingCloudPinyinEnginePendingSegment* _tmp1_;
			gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (self->priv->pending_segment_list), _tmp1_ = icp_ibus_binding_cloud_pinyin_engine_pending_segment_new_from_content (content));
			_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (_tmp1_);
			icp_ibus_binding_cloud_pinyin_engine_process_pending_list (self);
		}
	}
}


static void icp_ibus_binding_cloud_pinyin_engine_commit_pinyins (icpIBusBindingCloudPinyinEngine* self, icpPinyinSequence* pinyins) {
	g_return_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self));
	g_return_if_fail (ICP_PINYIN_IS_SEQUENCE (pinyins));
	if (icp_pinyin_sequence_get_size (pinyins) > 0) {
		icpIBusBindingCloudPinyinEnginePendingSegment* _tmp0_;
		gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (self->priv->pending_segment_list), _tmp0_ = icp_ibus_binding_cloud_pinyin_engine_pending_segment_new_from_pinyins (pinyins));
		_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (_tmp0_);
		icp_ibus_binding_cloud_pinyin_engine_process_pending_list (self);
	}
}


static void icp_ibus_binding_cloud_pinyin_engine_switch_offline_mode (icpIBusBindingCloudPinyinEngine* self) {
	g_return_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self));
	self->priv->offline_mode = !self->priv->offline_mode;
	if (!self->priv->offline_mode) {
		if (icp_lua_binding_get_engine_count () == 0) {
			icp_frontend_notify ("", "\n", "error");
			self->priv->offline_mode = TRUE;
		} else {
			icp_ibus_binding_cloud_pinyin_engine_start_requesting (self);
		}
	} else {
		icp_ibus_binding_cloud_pinyin_engine_stop_requesting (self);
	}
}


static void icp_ibus_binding_cloud_pinyin_engine_commit_buffer (icpIBusBindingCloudPinyinEngine* self) {
	g_return_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self));
	if (icp_pinyin_sequence_get_size (self->priv->pinyin_buffer) > 0) {
		gboolean _tmp0_ = FALSE;
		if (icp_config_switches_background_request) {
			_tmp0_ = !self->priv->offline_mode;
		} else {
			_tmp0_ = FALSE;
		}
		if (_tmp0_) {
			icp_ibus_binding_cloud_pinyin_engine_commit_pinyins (self, self->priv->pinyin_buffer);
		} else {
			icp_ibus_binding_cloud_pinyin_engine_commit (self, self->priv->pinyin_buffer_preedit);
		}
		self->priv->last_is_chinese = TRUE;
	}
	icp_ibus_binding_cloud_pinyin_engine_clear_buffer (self);
}


static void icp_ibus_binding_cloud_pinyin_engine_clear_buffer (icpIBusBindingCloudPinyinEngine* self) {
	char* _tmp0_;
	g_return_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self));
	self->priv->raw_buffer = (_tmp0_ = g_strdup (""), _g_free0 (self->priv->raw_buffer), _tmp0_);
	icp_ibus_binding_cloud_pinyin_engine_user_phrase_clear (self);
	icp_pinyin_sequence_clear (self->priv->pinyin_buffer);
}


static char* string_slice (const char* self, glong start, glong end) {
	char* result = NULL;
	glong string_length;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	const char* start_string;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = string_get_length (self);
	if (start < 0) {
		start = string_length + start;
	}
	if (end < 0) {
		end = string_length + end;
	}
	if (start >= 0) {
		_tmp0_ = start <= string_length;
	} else {
		_tmp0_ = FALSE;
	}
	g_return_val_if_fail (_tmp0_, NULL);
	if (end >= 0) {
		_tmp1_ = end <= string_length;
	} else {
		_tmp1_ = FALSE;
	}
	g_return_val_if_fail (_tmp1_, NULL);
	g_return_val_if_fail (start <= end, NULL);
	start_string = g_utf8_offset_to_pointer (self, start);
	result = g_strndup (start_string, ((gchar*) g_utf8_offset_to_pointer (start_string, end - start)) - ((gchar*) start_string));
	return result;
}


static gboolean string_contains (const char* self, const char* needle) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	result = strstr (self, needle) != NULL;
	return result;
}


static gpointer _icp_pinyin_sequence_ref0 (gpointer self) {
	return self ? icp_pinyin_sequence_ref (self) : NULL;
}


static gboolean icp_ibus_binding_cloud_pinyin_engine_real_process_key_event (IBusEngine* base, guint keyval, guint keycode, guint state) {
	icpIBusBindingCloudPinyinEngine * self;
	gboolean result = FALSE;
	gboolean handled;
	char* action;
	gboolean _tmp0_ = FALSE;
	self = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE (base);
	handled = FALSE;
	state = state & ICP_IBUS_BINDING_key_state_filter;
	action = NULL;
	if ((state & IBUS_RELEASE_MASK) != 0) {
		_tmp0_ = (self->priv->last_state & IBUS_RELEASE_MASK) != 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		char* _tmp1_;
		action = (_tmp1_ = g_strdup (""), _g_free0 (action), _tmp1_);
	} else {
		icpConfigKey* _tmp2_;
		char* _tmp3_;
		action = (_tmp3_ = icp_config_key_actions_get (_tmp2_ = icp_config_key_new (keyval, state, NULL)), _g_free0 (action), _tmp3_);
		_icp_config_key_unref0 (_tmp2_);
	}
	self->priv->last_state = state;
	{
		gboolean _tmp4_;
		_tmp4_ = TRUE;
		while (TRUE) {
			GeeHashSet* actions;
			gboolean _tmp7_ = FALSE;
			gboolean _tmp8_ = FALSE;
			gboolean _tmp10_ = FALSE;
			gboolean _tmp11_ = FALSE;
			gboolean _tmp13_ = FALSE;
			gboolean _tmp14_ = FALSE;
			gboolean _tmp58_ = FALSE;
			gboolean _tmp59_ = FALSE;
			gboolean _tmp60_ = FALSE;
			gboolean _tmp61_ = FALSE;
			gboolean _tmp70_ = FALSE;
			gboolean _tmp71_ = FALSE;
			if (!_tmp4_) {
				if (!FALSE) {
					break;
				}
			}
			_tmp4_ = FALSE;
			if (g_str_has_prefix (action, "lua:")) {
				char* _tmp5_;
				icp_lua_binding_do_string (_tmp5_ = string_slice (action, (glong) 4, string_get_length (action)));
				_g_free0 (_tmp5_);
				handled = TRUE;
				break;
			}
			actions = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL);
			{
				char** _tmp6_;
				char** v_collection;
				int v_collection_length1;
				int v_it;
				v_collection = _tmp6_ = g_strsplit (action, " ", 0);
				v_collection_length1 = _vala_array_length (_tmp6_);
				for (v_it = 0; v_it < _vala_array_length (_tmp6_); v_it = v_it + 1) {
					char* v;
					v = g_strdup (v_collection[v_it]);
					{
						gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (actions), v);
						_g_free0 (v);
					}
				}
				v_collection = (_vala_array_free (v_collection, v_collection_length1, (GDestroyNotify) g_free), NULL);
			}
			if (self->priv->chinese_mode == FALSE) {
				_tmp8_ = gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "chs");
			} else {
				_tmp8_ = FALSE;
			}
			if (_tmp8_) {
				_tmp7_ = TRUE;
			} else {
				gboolean _tmp9_ = FALSE;
				if (self->priv->chinese_mode == TRUE) {
					_tmp9_ = gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "eng");
				} else {
					_tmp9_ = FALSE;
				}
				_tmp7_ = _tmp9_;
			}
			if (_tmp7_) {
				self->priv->chinese_mode = !self->priv->chinese_mode;
				if (self->priv->chinese_mode) {
					self->priv->last_is_chinese = TRUE;
				}
				handled = TRUE;
				_g_object_unref0 (actions);
				break;
			}
			if (self->priv->traditional_mode) {
				_tmp11_ = gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "simp");
			} else {
				_tmp11_ = FALSE;
			}
			if (_tmp11_) {
				_tmp10_ = TRUE;
			} else {
				gboolean _tmp12_ = FALSE;
				if (!self->priv->traditional_mode) {
					_tmp12_ = gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "trad");
				} else {
					_tmp12_ = FALSE;
				}
				_tmp10_ = _tmp12_;
			}
			if (_tmp10_) {
				self->priv->traditional_mode = !self->priv->traditional_mode;
				handled = TRUE;
				_g_object_unref0 (actions);
				break;
			}
			if (self->priv->offline_mode) {
				_tmp14_ = gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "online");
			} else {
				_tmp14_ = FALSE;
			}
			if (_tmp14_) {
				_tmp13_ = TRUE;
			} else {
				gboolean _tmp15_ = FALSE;
				if (!self->priv->offline_mode) {
					_tmp15_ = gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "offline");
				} else {
					_tmp15_ = FALSE;
				}
				_tmp13_ = _tmp15_;
			}
			if (_tmp13_) {
				icp_ibus_binding_cloud_pinyin_engine_switch_offline_mode (self);
				handled = TRUE;
				_g_object_unref0 (actions);
				break;
			}
			if (self->priv->chinese_mode) {
				gboolean _tmp16_ = FALSE;
				gboolean _tmp28_ = FALSE;
				gboolean _tmp29_ = FALSE;
				gboolean _tmp53_ = FALSE;
				gboolean _tmp54_ = FALSE;
				gboolean _tmp55_ = FALSE;
				gboolean _tmp57_ = FALSE;
				if (!self->priv->correction_mode) {
					_tmp16_ = gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "correct");
				} else {
					_tmp16_ = FALSE;
				}
				if (_tmp16_) {
					if (string_get_length (self->priv->raw_buffer) > 1) {
						gboolean _tmp17_ = FALSE;
						if (icp_pinyin_sequence_get_size (self->priv->pinyin_buffer) > 0) {
							icpPinyinId* _tmp18_;
							_tmp17_ = icp_pinyin_id_get_vowel (_tmp18_ = icp_pinyin_sequence_get_id (self->priv->pinyin_buffer, 0)) > 0;
							_icp_pinyin_id_unref0 (_tmp18_);
						} else {
							_tmp17_ = FALSE;
						}
						if (_tmp17_) {
							self->priv->correction_mode = TRUE;
							handled = TRUE;
							_g_object_unref0 (actions);
							break;
						}
					} else {
						gboolean _tmp19_ = FALSE;
						if (icp_frontend_get_current_time () <= (((guint64) (1000000 * icp_config_timeouts_selection)) + icp_frontend_get_clipboard_update_time ())) {
							_tmp19_ = icp_ibus_binding_cloud_pinyin_engine_is_pending_segment_list_empty (self);
						} else {
							_tmp19_ = FALSE;
						}
						if (_tmp19_) {
							char* selection;
							gboolean _tmp20_ = FALSE;
							selection = icp_frontend_get_selection ();
							if (!string_contains (selection, "\n")) {
								icpPinyinSequence* _tmp21_ = NULL;
								gboolean _tmp22_;
								icpPinyinSequence* _tmp23_;
								_tmp20_ = (_tmp22_ = icp_database_reverse_convert (selection, &_tmp21_), self->priv->pinyin_buffer = (_tmp23_ = _tmp21_, _icp_pinyin_sequence_unref0 (self->priv->pinyin_buffer), _tmp23_), _tmp22_);
							} else {
								_tmp20_ = FALSE;
							}
							if (_tmp20_) {
								IBusText* _tmp24_;
								ibus_engine_commit_text (IBUS_ENGINE (self), _tmp24_ = g_object_ref_sink (ibus_text_new_from_string ("")));
								_g_object_unref0 (_tmp24_);
								self->priv->correction_mode = TRUE;
								if (icp_config_switches_double_pinyin) {
									char* _tmp25_;
									self->priv->raw_buffer = (_tmp25_ = icp_pinyin_sequence_to_double_pinyin_string (self->priv->pinyin_buffer, 0, -1), _g_free0 (self->priv->raw_buffer), _tmp25_);
								} else {
									char* _tmp26_;
									self->priv->raw_buffer = (_tmp26_ = icp_pinyin_sequence_to_string (self->priv->pinyin_buffer, 0, -1), _g_free0 (self->priv->raw_buffer), _tmp26_);
								}
								handled = TRUE;
								_g_free0 (selection);
								_g_object_unref0 (actions);
								break;
							} else {
								icpPinyinSequence* _tmp27_;
								self->priv->pinyin_buffer = (_tmp27_ = icp_pinyin_sequence_new (NULL), _icp_pinyin_sequence_unref0 (self->priv->pinyin_buffer), _tmp27_);
							}
							_g_free0 (selection);
						}
					}
				}
				if (!self->priv->correction_mode) {
					_tmp29_ = string_get_length (self->priv->raw_buffer) > 0;
				} else {
					_tmp29_ = FALSE;
				}
				if (_tmp29_) {
					_tmp28_ = gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "clear");
				} else {
					_tmp28_ = FALSE;
				}
				if (_tmp28_) {
					icp_ibus_binding_cloud_pinyin_engine_clear_buffer (self);
					handled = TRUE;
					_g_object_unref0 (actions);
					break;
				}
				if (!self->priv->correction_mode) {
					gboolean _tmp30_ = FALSE;
					gboolean is_backspace;
					if (gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "back")) {
						_tmp30_ = string_get_length (self->priv->raw_buffer) > 0;
					} else {
						_tmp30_ = FALSE;
					}
					is_backspace = _tmp30_;
					if (icp_config_switches_double_pinyin) {
						gboolean _tmp31_ = FALSE;
						gboolean _tmp32_ = FALSE;
						gboolean _tmp33_ = FALSE;
						if (icp_pinyin_double_pinyin_is_valid_key (keyval)) {
							_tmp33_ = state == 0;
						} else {
							_tmp33_ = FALSE;
						}
						if (_tmp33_) {
							gboolean _tmp34_ = FALSE;
							guint _tmp35_;
							if ((_tmp35_ = keyval, 'z' >= _tmp35_) && (_tmp35_ >= 'a')) {
								_tmp34_ = TRUE;
							} else {
								_tmp34_ = string_get_length (self->priv->raw_buffer) > 0;
							}
							_tmp32_ = _tmp34_;
						} else {
							_tmp32_ = FALSE;
						}
						if (_tmp32_) {
							_tmp31_ = TRUE;
						} else {
							_tmp31_ = is_backspace;
						}
						if (_tmp31_) {
							icpPinyinSequence* _tmp39_ = NULL;
							icpPinyinSequence* _tmp40_;
							if (is_backspace) {
								char* _tmp36_;
								self->priv->raw_buffer = (_tmp36_ = string_slice (self->priv->raw_buffer, (glong) 0, (glong) (-1)), _g_free0 (self->priv->raw_buffer), _tmp36_);
							} else {
								char* _tmp37_;
								char* _tmp38_;
								self->priv->raw_buffer = (_tmp38_ = g_strconcat (self->priv->raw_buffer, _tmp37_ = g_strdup_printf ("%c", (gint) keyval), NULL), _g_free0 (self->priv->raw_buffer), _tmp38_);
								_g_free0 (_tmp37_);
							}
							icp_pinyin_double_pinyin_convert (self->priv->raw_buffer, &_tmp39_);
							self->priv->pinyin_buffer = (_tmp40_ = _tmp39_, _icp_pinyin_sequence_unref0 (self->priv->pinyin_buffer), _tmp40_);
							handled = TRUE;
							_g_object_unref0 (actions);
							break;
						}
					} else {
						gboolean _tmp41_ = FALSE;
						gboolean _tmp42_ = FALSE;
						guint _tmp43_;
						gboolean _tmp48_ = FALSE;
						gboolean _tmp49_ = FALSE;
						if ((_tmp43_ = keyval, 'z' >= _tmp43_) && (_tmp43_ >= 'a')) {
							_tmp42_ = state == 0;
						} else {
							_tmp42_ = FALSE;
						}
						if (_tmp42_) {
							_tmp41_ = TRUE;
						} else {
							_tmp41_ = is_backspace;
						}
						if (_tmp41_) {
							icpPinyinSequence* _tmp47_;
							if (is_backspace) {
								char* _tmp44_;
								self->priv->raw_buffer = (_tmp44_ = string_slice (self->priv->raw_buffer, (glong) 0, (glong) (-1)), _g_free0 (self->priv->raw_buffer), _tmp44_);
							} else {
								char* _tmp45_;
								char* _tmp46_;
								self->priv->raw_buffer = (_tmp46_ = g_strconcat (self->priv->raw_buffer, _tmp45_ = g_strdup_printf ("%c", (gint) keyval), NULL), _g_free0 (self->priv->raw_buffer), _tmp46_);
								_g_free0 (_tmp45_);
							}
							self->priv->pinyin_buffer = (_tmp47_ = icp_pinyin_sequence_new (self->priv->raw_buffer), _icp_pinyin_sequence_unref0 (self->priv->pinyin_buffer), _tmp47_);
							handled = TRUE;
							_g_object_unref0 (actions);
							break;
						}
						if (gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "sep")) {
							_tmp49_ = string_get_length (self->priv->raw_buffer) > 0;
						} else {
							_tmp49_ = FALSE;
						}
						if (_tmp49_) {
							_tmp48_ = ((guint) g_utf8_get_char (g_utf8_offset_to_pointer (self->priv->raw_buffer, string_get_length (self->priv->raw_buffer) - 1))) != keyval;
						} else {
							_tmp48_ = FALSE;
						}
						if (_tmp48_) {
							char* _tmp50_;
							char* _tmp51_;
							self->priv->raw_buffer = (_tmp51_ = g_strconcat (self->priv->raw_buffer, _tmp50_ = g_strdup_printf ("%c", (gint) keyval), NULL), _g_free0 (self->priv->raw_buffer), _tmp51_);
							_g_free0 (_tmp50_);
							handled = TRUE;
							_g_object_unref0 (actions);
							break;
						}
					}
				}
				if (self->priv->table_visible) {
					if (gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "pgup")) {
						g_signal_emit_by_name (IBUS_ENGINE (self), "page-up");
						handled = TRUE;
					}
					if (gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "pgdn")) {
						g_signal_emit_by_name (IBUS_ENGINE (self), "page-down");
						handled = TRUE;
					}
					if (handled) {
						ibus_engine_update_lookup_table (IBUS_ENGINE (self), self->priv->table, TRUE);
						_g_object_unref0 (actions);
						break;
					}
					{
						GeeIterator* _s_it;
						_s_it = gee_abstract_collection_iterator (GEE_ABSTRACT_COLLECTION (actions));
						while (TRUE) {
							char* s;
							if (!gee_iterator_next (_s_it)) {
								break;
							}
							s = (char*) gee_iterator_get (_s_it);
							if (g_str_has_prefix (s, "cand:")) {
								guint index;
								gboolean _tmp52_ = FALSE;
								index = (guint) 0;
								sscanf (s, "cand:%u", &index);
								if (ibus_lookup_table_get_number_of_candidates (self->priv->table) > ((ibus_lookup_table_get_page_size (self->priv->table) * self->priv->page_index) + index)) {
									_tmp52_ = icp_config_candidate_labels_get_size () > index;
								} else {
									_tmp52_ = FALSE;
								}
								if (_tmp52_) {
									g_signal_emit_by_name (IBUS_ENGINE (self), "candidate-clicked", index, (guint) 128, (guint) 0);
									handled = TRUE;
								}
								_g_free0 (s);
								break;
							}
							_g_free0 (s);
						}
						_g_object_unref0 (_s_it);
					}
					if (handled) {
						_g_object_unref0 (actions);
						break;
					}
				}
				if ((state ^ IBUS_SHIFT_MASK) == 0) {
					_tmp55_ = TRUE;
				} else {
					_tmp55_ = state == 0;
				}
				if (_tmp55_) {
					guint _tmp56_;
					_tmp54_ = (_tmp56_ = keyval, 128 > _tmp56_) && (_tmp56_ >= 32);
				} else {
					_tmp54_ = FALSE;
				}
				if (_tmp54_) {
					_tmp53_ = icp_config_punctuations_exists ((gint) keyval);
				} else {
					_tmp53_ = FALSE;
				}
				if (_tmp53_) {
					char* punc;
					icp_ibus_binding_cloud_pinyin_engine_commit_buffer (self);
					punc = icp_config_punctuations_get ((gint) keyval, self->priv->last_is_chinese);
					icp_ibus_binding_cloud_pinyin_engine_user_phrase_clear (self);
					icp_ibus_binding_cloud_pinyin_engine_commit (self, punc);
					handled = TRUE;
					_g_free0 (punc);
					_g_object_unref0 (actions);
					break;
				}
				if (self->priv->correction_mode) {
					_tmp57_ = gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "back");
				} else {
					_tmp57_ = FALSE;
				}
				if (_tmp57_) {
					handled = TRUE;
					_g_object_unref0 (actions);
					break;
				}
			}
			if (gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "raw")) {
				_tmp58_ = string_get_length (self->priv->raw_buffer) > 0;
			} else {
				_tmp58_ = FALSE;
			}
			if (_tmp58_) {
				icp_ibus_binding_cloud_pinyin_engine_commit (self, self->priv->raw_buffer);
				icp_ibus_binding_cloud_pinyin_engine_clear_buffer (self);
				self->priv->last_is_chinese = FALSE;
				handled = TRUE;
				_g_object_unref0 (actions);
				break;
			}
			if (gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "commit")) {
				_tmp59_ = icp_pinyin_sequence_get_size (self->priv->pinyin_buffer) > 0;
			} else {
				_tmp59_ = FALSE;
			}
			if (_tmp59_) {
				icp_ibus_binding_cloud_pinyin_engine_commit_buffer (self);
				handled = TRUE;
				_g_object_unref0 (actions);
				break;
			}
			if (gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (actions), "back")) {
				_tmp61_ = !icp_ibus_binding_cloud_pinyin_engine_is_pending_segment_list_empty (self);
			} else {
				_tmp61_ = FALSE;
			}
			if (_tmp61_) {
				_tmp60_ = string_get_length (self->priv->raw_buffer) == 0;
			} else {
				_tmp60_ = FALSE;
			}
			if (_tmp60_) {
				{
					gint i;
					i = gee_collection_get_size (GEE_COLLECTION (self->priv->pending_segment_list)) - 1;
					{
						gboolean _tmp62_;
						_tmp62_ = TRUE;
						while (TRUE) {
							icpIBusBindingCloudPinyinEnginePendingSegment* seg;
							if (!_tmp62_) {
								i--;
							}
							_tmp62_ = FALSE;
							if (!(i >= 0)) {
								break;
							}
							seg = (icpIBusBindingCloudPinyinEnginePendingSegment*) gee_abstract_list_get (GEE_ABSTRACT_LIST (self->priv->pending_segment_list), i);
							if (seg->content != NULL) {
								if (string_get_length (seg->content) <= 1) {
									icpIBusBindingCloudPinyinEnginePendingSegment* _tmp63_;
									_tmp63_ = (icpIBusBindingCloudPinyinEnginePendingSegment*) gee_abstract_list_remove_at (GEE_ABSTRACT_LIST (self->priv->pending_segment_list), i);
									_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (_tmp63_);
								} else {
									char* _tmp64_;
									seg->content = (_tmp64_ = string_slice (seg->content, (glong) 0, string_get_length (seg->content) - 1), _g_free0 (seg->content), _tmp64_);
								}
								_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (seg);
								break;
							}
							if (seg->pinyins != NULL) {
								icpPinyinSequence* pinyins;
								icpPinyinSequence* _tmp65_;
								char* _tmp66_;
								icpPinyinSequence* _tmp69_;
								pinyins = icp_pinyin_sequence_new_copy (seg->pinyins, 0, icp_pinyin_sequence_get_size (seg->pinyins) - 1);
								seg->pinyins = (_tmp65_ = NULL, _icp_pinyin_sequence_unref0 (seg->pinyins), _tmp65_);
								seg->content = (_tmp66_ = NULL, _g_free0 (seg->content), _tmp66_);
								if (icp_config_switches_double_pinyin) {
									char* _tmp67_;
									self->priv->raw_buffer = (_tmp67_ = icp_pinyin_sequence_to_double_pinyin_string (pinyins, 0, -1), _g_free0 (self->priv->raw_buffer), _tmp67_);
								} else {
									char* _tmp68_;
									self->priv->raw_buffer = (_tmp68_ = icp_pinyin_sequence_to_string (pinyins, 0, -1), _g_free0 (self->priv->raw_buffer), _tmp68_);
								}
								self->priv->pinyin_buffer = (_tmp69_ = _icp_pinyin_sequence_ref0 (pinyins), _icp_pinyin_sequence_unref0 (self->priv->pinyin_buffer), _tmp69_);
								_icp_pinyin_sequence_unref0 (pinyins);
								_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (seg);
								break;
							}
							_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (seg);
						}
					}
				}
				handled = TRUE;
				_g_object_unref0 (actions);
				break;
			}
			if ((state ^ IBUS_SHIFT_MASK) == 0) {
				_tmp71_ = TRUE;
			} else {
				_tmp71_ = state == 0;
			}
			if (_tmp71_) {
				gboolean _tmp72_ = FALSE;
				guint _tmp73_;
				if ((_tmp73_ = keyval, 128 > _tmp73_) && (_tmp73_ >= 32)) {
					_tmp72_ = TRUE;
				} else {
					gboolean _tmp74_ = FALSE;
					if (keyval == IBUS_Return) {
						_tmp74_ = !icp_ibus_binding_cloud_pinyin_engine_is_pending_segment_list_empty (self);
					} else {
						_tmp74_ = FALSE;
					}
					_tmp72_ = _tmp74_;
				}
				_tmp70_ = _tmp72_;
			} else {
				_tmp70_ = FALSE;
			}
			if (_tmp70_) {
				char* punc;
				icp_ibus_binding_cloud_pinyin_engine_commit_buffer (self);
				if (keyval == IBUS_Return) {
					keyval = (guint) 13;
				}
				punc = g_strdup_printf ("%c", (gint) keyval);
				self->priv->last_is_chinese = FALSE;
				icp_ibus_binding_cloud_pinyin_engine_commit (self, punc);
				handled = TRUE;
				_g_free0 (punc);
				_g_object_unref0 (actions);
				break;
			}
			_g_object_unref0 (actions);
		}
	}
	if (handled) {
		if (!self->priv->offline_mode) {
			self->priv->last_prerequest_done = FALSE;
			icp_ibus_binding_cloud_pinyin_engine_start_requesting (self);
		}
		icp_ibus_binding_cloud_pinyin_engine_process_pending_list (self);
		icp_ibus_binding_cloud_pinyin_engine_update_preedit (self);
		icp_ibus_binding_cloud_pinyin_engine_update_properties (self);
		icp_ibus_binding_cloud_pinyin_engine_update_candidates (self);
	}
	result = handled;
	_g_free0 (action);
	return result;
}


static void icp_ibus_binding_cloud_pinyin_engine_real_page_up (IBusEngine* base) {
	icpIBusBindingCloudPinyinEngine * self;
	gboolean _tmp0_ = FALSE;
	self = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE (base);
	if (self->priv->table_visible) {
		_tmp0_ = ibus_lookup_table_page_up (self->priv->table);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		ibus_engine_update_lookup_table (IBUS_ENGINE (self), self->priv->table, TRUE);
		self->priv->page_index--;
	}
}


static void icp_ibus_binding_cloud_pinyin_engine_real_page_down (IBusEngine* base) {
	icpIBusBindingCloudPinyinEngine * self;
	gboolean _tmp0_ = FALSE;
	self = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE (base);
	if (self->priv->table_visible) {
		_tmp0_ = ibus_lookup_table_page_down (self->priv->table);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		ibus_engine_update_lookup_table (IBUS_ENGINE (self), self->priv->table, TRUE);
		self->priv->page_index++;
	}
}


static void icp_ibus_binding_cloud_pinyin_engine_user_phrase_clear (icpIBusBindingCloudPinyinEngine* self) {
	char* _tmp0_;
	g_return_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self));
	self->priv->user_phrase = (_tmp0_ = g_strdup (""), _g_free0 (self->priv->user_phrase), _tmp0_);
	gee_abstract_collection_clear (GEE_ABSTRACT_COLLECTION (self->priv->user_pinyins));
}


static void icp_ibus_binding_cloud_pinyin_engine_real_candidate_clicked (IBusEngine* base, guint index, guint button, guint state) {
	icpIBusBindingCloudPinyinEngine * self;
	IBusText* candidate;
	char* content;
	gint len;
	char* _tmp0_;
	icpPinyinSequence* pinyins;
	gboolean _tmp3_ = FALSE;
	char* _tmp4_;
	self = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE (base);
	index = index + (ibus_lookup_table_get_page_size (self->priv->table) * self->priv->page_index);
	candidate = _g_object_ref0 (ibus_lookup_table_get_candidate (self->priv->table, index));
	content = g_strdup (candidate->text);
	len = (gint) string_get_length (content);
	icp_ibus_binding_cloud_pinyin_engine_commit (self, content);
	self->priv->user_phrase = (_tmp0_ = g_strconcat (self->priv->user_phrase, content, NULL), _g_free0 (self->priv->user_phrase), _tmp0_);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				icpPinyinId* _tmp2_;
				if (!_tmp1_) {
					i++;
				}
				_tmp1_ = FALSE;
				if (!(i < string_get_length (content))) {
					break;
				}
				gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (self->priv->user_pinyins), _tmp2_ = icp_pinyin_sequence_get_id (self->priv->pinyin_buffer, i));
				_icp_pinyin_id_unref0 (_tmp2_);
			}
		}
	}
	pinyins = icp_pinyin_sequence_new_ids (self->priv->user_pinyins);
	if (index != self->priv->cloud_candidate_count) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = _vala_strcmp0 (content, self->priv->user_phrase) != 0;
	}
	if (_tmp3_) {
		icp_database_insert (self->priv->user_phrase, pinyins, -3000.0, 200, TRUE);
	}
	icp_dbus_binding_set_response (_tmp4_ = icp_pinyin_sequence_to_string (pinyins, 0, -1), self->priv->user_phrase, 128);
	_g_free0 (_tmp4_);
	if (icp_config_switches_double_pinyin) {
		char* _tmp5_;
		icpPinyinSequence* _tmp6_ = NULL;
		icpPinyinSequence* _tmp7_;
		self->priv->raw_buffer = (_tmp5_ = icp_pinyin_sequence_to_double_pinyin_string (self->priv->pinyin_buffer, len, -1), _g_free0 (self->priv->raw_buffer), _tmp5_);
		icp_pinyin_double_pinyin_convert (self->priv->raw_buffer, &_tmp6_);
		self->priv->pinyin_buffer = (_tmp7_ = _tmp6_, _icp_pinyin_sequence_unref0 (self->priv->pinyin_buffer), _tmp7_);
	} else {
		char* _tmp8_;
		icpPinyinSequence* _tmp9_;
		self->priv->raw_buffer = (_tmp8_ = icp_pinyin_sequence_to_string (self->priv->pinyin_buffer, len, -1), _g_free0 (self->priv->raw_buffer), _tmp8_);
		self->priv->pinyin_buffer = (_tmp9_ = icp_pinyin_sequence_new (self->priv->raw_buffer), _icp_pinyin_sequence_unref0 (self->priv->pinyin_buffer), _tmp9_);
	}
	if (strlen (self->priv->raw_buffer) == 0) {
		icp_ibus_binding_cloud_pinyin_engine_user_phrase_clear (self);
	}
	if (button != 128) {
		icp_ibus_binding_cloud_pinyin_engine_update_preedit (self);
		icp_ibus_binding_cloud_pinyin_engine_update_candidates (self);
	}
	_icp_pinyin_sequence_unref0 (pinyins);
	_g_free0 (content);
	_g_object_unref0 (candidate);
}


static const char* string_to_string (const char* self) {
	const char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static void icp_ibus_binding_cloud_pinyin_engine_update_preedit (icpIBusBindingCloudPinyinEngine* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self));
	if (icp_pinyin_sequence_get_size (self->priv->pinyin_buffer) == 0) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp1_ = FALSE;
		if (!icp_config_switches_show_pinyin_auxiliary) {
			_tmp1_ = !icp_config_switches_show_raw_in_auxiliary;
		} else {
			_tmp1_ = FALSE;
		}
		_tmp0_ = _tmp1_;
	}
	if (_tmp0_) {
		ibus_engine_hide_auxiliary_text (IBUS_ENGINE (self));
	} else {
		char* _tmp2_;
		char* pinyin_buffer_aux;
		char* _tmp5_;
		char* raw_buffer_aux;
		char* _tmp8_;
		IBusText* _tmp9_;
		IBusText* text;
		_tmp2_ = NULL;
		if (icp_config_switches_show_pinyin_auxiliary) {
			char* _tmp3_;
			_tmp2_ = (_tmp3_ = icp_pinyin_sequence_to_string (self->priv->pinyin_buffer, 0, -1), _g_free0 (_tmp2_), _tmp3_);
		} else {
			char* _tmp4_;
			_tmp2_ = (_tmp4_ = g_strdup (""), _g_free0 (_tmp2_), _tmp4_);
		}
		pinyin_buffer_aux = g_strdup (_tmp2_);
		_tmp5_ = NULL;
		if (icp_config_switches_show_raw_in_auxiliary) {
			char* _tmp6_;
			_tmp5_ = (_tmp6_ = g_strdup_printf (" [%s]", self->priv->raw_buffer), _g_free0 (_tmp5_), _tmp6_);
		} else {
			char* _tmp7_;
			_tmp5_ = (_tmp7_ = g_strdup (""), _g_free0 (_tmp5_), _tmp7_);
		}
		raw_buffer_aux = g_strdup (_tmp5_);
		text = (_tmp9_ = g_object_ref_sink (ibus_text_new_from_string (_tmp8_ = g_strconcat (string_to_string (pinyin_buffer_aux), string_to_string (raw_buffer_aux), NULL))), _g_free0 (_tmp8_), _tmp9_);
		icp_config_colors_color_apply (icp_config_colors_buffer_pinyin, text, (guint) 0, (gint) string_get_length (pinyin_buffer_aux));
		icp_config_colors_color_apply (icp_config_colors_buffer_raw, text, (guint) string_get_length (pinyin_buffer_aux), (gint) (string_get_length (pinyin_buffer_aux) + string_get_length (raw_buffer_aux)));
		ibus_engine_update_auxiliary_text (IBUS_ENGINE (self), text, TRUE);
		_g_object_unref0 (text);
		_g_free0 (raw_buffer_aux);
		_g_free0 (_tmp5_);
		_g_free0 (pinyin_buffer_aux);
		_g_free0 (_tmp2_);
	}
	{
		gint cloud_length = 0;
		char* _tmp10_;
		GeeArrayList* color_list;
		char* pending_preedit;
		gint pending_preedit_length;
		char* preedit;
		IBusText* text;
		gint _tmp17_ = 0;
		self->priv->pinyin_buffer_preedit = (_tmp10_ = icp_dbus_binding_convert (self->priv->pinyin_buffer, self->priv->offline_mode, &cloud_length), _g_free0 (self->priv->pinyin_buffer_preedit), _tmp10_);
		color_list = gee_array_list_new (ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT, (GBoxedCopyFunc) icp_ibus_binding_cloud_pinyin_engine_color_segment_ref, icp_ibus_binding_cloud_pinyin_engine_color_segment_unref, NULL);
		pending_preedit = g_strdup ("");
		pending_preedit_length = 0;
		{
			GeeIterator* _seg_it;
			_seg_it = gee_abstract_collection_iterator (GEE_ABSTRACT_COLLECTION (self->priv->pending_segment_list));
			while (TRUE) {
				icpIBusBindingCloudPinyinEnginePendingSegment* seg;
				gboolean _tmp11_ = FALSE;
				if (!gee_iterator_next (_seg_it)) {
					break;
				}
				seg = (icpIBusBindingCloudPinyinEnginePendingSegment*) gee_iterator_get (_seg_it);
				if (seg->content == NULL) {
					_tmp11_ = seg->pinyins != NULL;
				} else {
					_tmp11_ = FALSE;
				}
				if (_tmp11_) {
					gint cloud_len = 0;
					char* content;
					char* _tmp12_;
					icpIBusBindingCloudPinyinEngineColorSegment* _tmp13_;
					icpIBusBindingCloudPinyinEngineColorSegment* _tmp14_;
					content = icp_dbus_binding_convert (seg->pinyins, self->priv->offline_mode, &cloud_len);
					pending_preedit = (_tmp12_ = g_strconcat (pending_preedit, content, NULL), _g_free0 (pending_preedit), _tmp12_);
					gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (color_list), _tmp13_ = icp_ibus_binding_cloud_pinyin_engine_color_segment_new (icp_config_colors_preedit_remote, (guint) pending_preedit_length, pending_preedit_length + cloud_len));
					_icp_ibus_binding_cloud_pinyin_engine_color_segment_unref0 (_tmp13_);
					gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (color_list), _tmp14_ = icp_ibus_binding_cloud_pinyin_engine_color_segment_new (icp_config_colors_preedit_local, (guint) (pending_preedit_length + cloud_len), pending_preedit_length + ((gint) string_get_length (content))));
					_icp_ibus_binding_cloud_pinyin_engine_color_segment_unref0 (_tmp14_);
					pending_preedit_length = pending_preedit_length + ((gint) string_get_length (content));
					_g_free0 (content);
					_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (seg);
					continue;
				}
				if (seg->content != NULL) {
					char* _tmp15_;
					icpIBusBindingCloudPinyinEngineColorSegment* _tmp16_;
					pending_preedit = (_tmp15_ = g_strconcat (pending_preedit, seg->content, NULL), _g_free0 (pending_preedit), _tmp15_);
					gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (color_list), _tmp16_ = icp_ibus_binding_cloud_pinyin_engine_color_segment_new (icp_config_colors_preedit_fixed, (guint) pending_preedit_length, pending_preedit_length + ((gint) string_get_length (seg->content))));
					_icp_ibus_binding_cloud_pinyin_engine_color_segment_unref0 (_tmp16_);
					pending_preedit_length = pending_preedit_length + ((gint) string_get_length (seg->content));
					_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (seg);
					continue;
				}
				_icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref0 (seg);
			}
			_g_object_unref0 (_seg_it);
		}
		preedit = g_strconcat (pending_preedit, self->priv->pinyin_buffer_preedit, NULL);
		text = g_object_ref_sink (ibus_text_new_from_string (preedit));
		{
			GeeIterator* _i_it;
			_i_it = gee_abstract_collection_iterator (GEE_ABSTRACT_COLLECTION (color_list));
			while (TRUE) {
				icpIBusBindingCloudPinyinEngineColorSegment* i;
				if (!gee_iterator_next (_i_it)) {
					break;
				}
				i = (icpIBusBindingCloudPinyinEngineColorSegment*) gee_iterator_get (_i_it);
				icp_ibus_binding_cloud_pinyin_engine_color_segment_apply (i, text);
				_icp_ibus_binding_cloud_pinyin_engine_color_segment_unref0 (i);
			}
			_g_object_unref0 (_i_it);
		}
		if (self->priv->correction_mode) {
			icp_config_colors_color_apply (icp_config_colors_preedit_correcting, text, (guint) pending_preedit_length, -1);
		} else {
			icp_config_colors_color_apply (icp_config_colors_preedit_remote, text, (guint) pending_preedit_length, cloud_length + pending_preedit_length);
			icp_config_colors_color_apply (icp_config_colors_preedit_local, text, (guint) (cloud_length + pending_preedit_length), -1);
		}
		ibus_text_append_attribute (text, (guint) IBUS_ATTR_TYPE_UNDERLINE, (guint) IBUS_ATTR_UNDERLINE_SINGLE, (guint) pending_preedit_length, (gint) ibus_text_get_length (text));
		if (self->priv->correction_mode) {
			_tmp17_ = 0;
		} else {
			_tmp17_ = (gint) ibus_text_get_length (text);
		}
		ibus_engine_update_preedit_text (IBUS_ENGINE (self), text, (guint) _tmp17_, string_get_length (preedit) > 0);
		_g_object_unref0 (text);
		_g_free0 (preedit);
		_g_free0 (pending_preedit);
		_g_object_unref0 (color_list);
	}
}


static void icp_ibus_binding_cloud_pinyin_engine_update_candidates (icpIBusBindingCloudPinyinEngine* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self));
	if (icp_pinyin_sequence_get_size (self->priv->pinyin_buffer) > 0) {
		gboolean _tmp1_ = FALSE;
		if (icp_config_switches_always_show_candidates) {
			_tmp1_ = TRUE;
		} else {
			_tmp1_ = self->priv->correction_mode;
		}
		_tmp0_ = _tmp1_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gboolean _tmp2_ = FALSE;
		char* _tmp3_;
		gboolean _tmp4_;
		if ((_tmp4_ = _vala_strcmp0 (self->priv->last_pinyin_buffer_string, _tmp3_ = icp_pinyin_sequence_to_string (self->priv->pinyin_buffer, 0, -1)) != 0, _g_free0 (_tmp3_), _tmp4_)) {
			_tmp2_ = TRUE;
		} else {
			_tmp2_ = self->priv->last_correction_mode != self->priv->correction_mode;
		}
		if (_tmp2_) {
			GeeArrayList* candidates;
			GeeHashSet* candidate_set;
			gint candidate_index;
			char* _tmp18_;
			candidates = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
			ibus_lookup_table_clear (self->priv->table);
			self->priv->page_index = (guint) 0;
			self->priv->cloud_candidate_count = 0;
			if (!self->priv->offline_mode) {
				gint last_cloud_candidate_length;
				char* last_cloud_candidate;
				last_cloud_candidate_length = -16;
				last_cloud_candidate = g_strdup (".");
				{
					gint i;
					i = 2;
					{
						gboolean _tmp5_;
						_tmp5_ = TRUE;
						while (TRUE) {
							gboolean _tmp6_ = FALSE;
							char* _tmp7_;
							char* _tmp8_;
							char* cloud_candidate;
							gboolean _tmp9_ = FALSE;
							if (!_tmp5_) {
								i++;
							}
							_tmp5_ = FALSE;
							if (i < icp_pinyin_sequence_get_size (self->priv->pinyin_buffer)) {
								_tmp6_ = self->priv->cloud_candidate_count < icp_config_limits_cloud_candidates_limit;
							} else {
								_tmp6_ = FALSE;
							}
							if (!_tmp6_) {
								break;
							}
							cloud_candidate = (_tmp8_ = icp_dbus_binding_query (_tmp7_ = icp_pinyin_sequence_to_string (self->priv->pinyin_buffer, 0, i)), _g_free0 (_tmp7_), _tmp8_);
							if (strlen (cloud_candidate) > 0) {
								gboolean _tmp10_ = FALSE;
								if ((string_get_length (cloud_candidate) - last_cloud_candidate_length) > 2) {
									_tmp10_ = TRUE;
								} else {
									gboolean _tmp11_ = FALSE;
									if (string_get_length (cloud_candidate) > string_get_length (last_cloud_candidate)) {
										char* _tmp12_;
										_tmp11_ = _vala_strcmp0 (_tmp12_ = string_slice (cloud_candidate, (glong) 0, string_get_length (last_cloud_candidate)), last_cloud_candidate) != 0;
										_g_free0 (_tmp12_);
									} else {
										_tmp11_ = FALSE;
									}
									_tmp10_ = _tmp11_;
								}
								_tmp9_ = _tmp10_;
							} else {
								_tmp9_ = FALSE;
							}
							if (_tmp9_) {
								char* _tmp13_;
								self->priv->cloud_candidate_count++;
								last_cloud_candidate_length = i;
								gee_abstract_list_insert (GEE_ABSTRACT_LIST (candidates), 0, cloud_candidate);
								last_cloud_candidate = (_tmp13_ = g_strdup (cloud_candidate), _g_free0 (last_cloud_candidate), _tmp13_);
							}
							_g_free0 (cloud_candidate);
						}
					}
				}
				_g_free0 (last_cloud_candidate);
			}
			icp_database_query (self->priv->pinyin_buffer, candidates, icp_config_limits_db_query_limit, 1.05);
			{
				gint i;
				i = 0;
				{
					gboolean _tmp14_;
					_tmp14_ = TRUE;
					while (TRUE) {
						gboolean _tmp15_ = FALSE;
						char* _tmp16_;
						IBusText* _tmp17_;
						if (!_tmp14_) {
							i++;
						}
						_tmp14_ = FALSE;
						if (!(i < icp_config_candidate_labels_get_size ())) {
							break;
						}
						if (icp_config_switches_always_show_candidates) {
							_tmp15_ = !self->priv->correction_mode;
						} else {
							_tmp15_ = FALSE;
						}
						ibus_lookup_table_set_label (self->priv->table, (guint) i, _tmp17_ = g_object_ref_sink (ibus_text_new_from_string (_tmp16_ = icp_config_candidate_labels_get (i, _tmp15_))));
						_g_object_unref0 (_tmp17_);
						_g_free0 (_tmp16_);
					}
				}
			}
			candidate_set = gee_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL);
			candidate_index = 0;
			{
				GeeIterator* _s_it;
				_s_it = gee_abstract_collection_iterator (GEE_ABSTRACT_COLLECTION (candidates));
				while (TRUE) {
					char* s;
					IBusText* text;
					if (!gee_iterator_next (_s_it)) {
						break;
					}
					s = (char*) gee_iterator_get (_s_it);
					if (gee_abstract_collection_contains (GEE_ABSTRACT_COLLECTION (candidate_set), s)) {
						_g_free0 (s);
						continue;
					}
					gee_abstract_collection_add (GEE_ABSTRACT_COLLECTION (candidate_set), s);
					text = g_object_ref_sink (ibus_text_new_from_string (s));
					if ((candidate_index = candidate_index + 1) <= self->priv->cloud_candidate_count) {
						icp_config_colors_color_apply (icp_config_colors_candidate_remote, text, 0, -1);
					} else {
						icp_config_colors_color_apply (icp_config_colors_candidate_local, text, 0, -1);
					}
					ibus_lookup_table_append_candidate (self->priv->table, text);
					_g_object_unref0 (text);
					_g_free0 (s);
				}
				_g_object_unref0 (_s_it);
			}
			self->priv->table_visible = gee_collection_get_size (GEE_COLLECTION (candidates)) > 0;
			ibus_engine_update_lookup_table (IBUS_ENGINE (self), self->priv->table, self->priv->table_visible);
			self->priv->last_pinyin_buffer_string = (_tmp18_ = icp_pinyin_sequence_to_string (self->priv->pinyin_buffer, 0, -1), _g_free0 (self->priv->last_pinyin_buffer_string), _tmp18_);
			self->priv->last_correction_mode = self->priv->correction_mode;
			_g_object_unref0 (candidate_set);
			_g_object_unref0 (candidates);
		}
	} else {
		char* _tmp19_;
		self->priv->table_visible = FALSE;
		ibus_engine_hide_lookup_table (IBUS_ENGINE (self));
		if (icp_pinyin_sequence_get_size (self->priv->pinyin_buffer) == 0) {
			self->priv->correction_mode = FALSE;
		}
		self->priv->last_pinyin_buffer_string = (_tmp19_ = g_strdup (""), _g_free0 (self->priv->last_pinyin_buffer_string), _tmp19_);
	}
}


static void icp_ibus_binding_cloud_pinyin_engine_update_properties (icpIBusBindingCloudPinyinEngine* self) {
	g_return_if_fail (ICP_IBUS_BINDING_IS_CLOUD_PINYIN_ENGINE (self));
	if (!IBUS_ENGINE (self)->enabled) {
		return;
	}
	if (self->priv->last_chinese_mode != self->priv->chinese_mode) {
		const char* _tmp0_;
		char* _tmp1_;
		_tmp0_ = NULL;
		if (self->priv->chinese_mode) {
			_tmp0_ = "enabled";
		} else {
			_tmp0_ = "disabled";
		}
		ibus_property_set_icon (self->priv->chinese_mode_icon, _tmp1_ = g_strdup_printf ("%s/icons/pinyin-%s.png", icp_config_get_global_data_path (), _tmp0_));
		_g_free0 (_tmp1_);
		self->priv->last_chinese_mode = self->priv->chinese_mode;
		ibus_engine_update_property (IBUS_ENGINE (self), self->priv->chinese_mode_icon);
	}
	if (self->priv->last_traditional_mode != self->priv->traditional_mode) {
		const char* _tmp2_;
		char* _tmp3_;
		_tmp2_ = NULL;
		if (self->priv->traditional_mode) {
			_tmp2_ = "enabled";
		} else {
			_tmp2_ = "disabled";
		}
		ibus_property_set_icon (self->priv->traditional_conversion_icon, _tmp3_ = g_strdup_printf ("%s/icons/traditional-%s.png", icp_config_get_global_data_path (), _tmp2_));
		_g_free0 (_tmp3_);
		self->priv->last_traditional_mode = self->priv->traditional_mode;
		ibus_engine_update_property (IBUS_ENGINE (self), self->priv->traditional_conversion_icon);
	}
	if (self->priv->last_offline_mode != self->priv->offline_mode) {
		char* _tmp4_;
		char* _tmp7_;
		if (self->priv->offline_mode) {
			icp_ibus_binding_cloud_pinyin_engine_stop_requesting (self);
		}
		_tmp4_ = NULL;
		if (self->priv->offline_mode) {
			char* _tmp5_;
			_tmp4_ = (_tmp5_ = g_strdup ("offline"), _g_free0 (_tmp4_), _tmp5_);
		} else {
			char* _tmp6_;
			_tmp4_ = (_tmp6_ = g_strdup_printf ("idle-%d", icp_lua_binding_get_engine_speed_rank (0, 4)), _g_free0 (_tmp4_), _tmp6_);
		}
		ibus_property_set_icon (self->priv->status_icon, _tmp7_ = g_strdup_printf ("%s/icons/%s.png", icp_config_get_global_data_path (), _tmp4_));
		_g_free0 (_tmp7_);
		self->priv->last_offline_mode = self->priv->offline_mode;
		ibus_engine_update_property (IBUS_ENGINE (self), self->priv->status_icon);
		_g_free0 (_tmp4_);
	}
}


icpIBusBindingCloudPinyinEngine* icp_ibus_binding_cloud_pinyin_engine_construct (GType object_type) {
	icpIBusBindingCloudPinyinEngine * self;
	self = g_object_newv (object_type, 0, NULL);
	return self;
}


icpIBusBindingCloudPinyinEngine* icp_ibus_binding_cloud_pinyin_engine_new (void) {
	return icp_ibus_binding_cloud_pinyin_engine_construct (ICP_IBUS_BINDING_TYPE_CLOUD_PINYIN_ENGINE);
}


static icpIBusBindingCloudPinyinEnginePendingSegment* icp_ibus_binding_cloud_pinyin_engine_pending_segment_construct_from_content (GType object_type, const char* content) {
	icpIBusBindingCloudPinyinEnginePendingSegment* self = (icpIBusBindingCloudPinyinEnginePendingSegment*) g_type_create_instance (object_type);
	char* _tmp0_;
	icpPinyinSequence* _tmp1_;
	g_return_val_if_fail (content != NULL, NULL);
	self->content = (_tmp0_ = g_strdup (content), _g_free0 (self->content), _tmp0_);
	self->pinyins = (_tmp1_ = NULL, _icp_pinyin_sequence_unref0 (self->pinyins), _tmp1_);
	self->done = TRUE;
	self->retry = 0;
	return self;
}


static icpIBusBindingCloudPinyinEnginePendingSegment* icp_ibus_binding_cloud_pinyin_engine_pending_segment_new_from_content (const char* content) {
	return icp_ibus_binding_cloud_pinyin_engine_pending_segment_construct_from_content (ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT, content);
}


static icpIBusBindingCloudPinyinEnginePendingSegment* icp_ibus_binding_cloud_pinyin_engine_pending_segment_construct_from_pinyins (GType object_type, icpPinyinSequence* pinyins) {
	icpIBusBindingCloudPinyinEnginePendingSegment* self = (icpIBusBindingCloudPinyinEnginePendingSegment*) g_type_create_instance (object_type);
	char* _tmp0_;
	icpPinyinSequence* _tmp1_;
	g_return_val_if_fail (ICP_PINYIN_IS_SEQUENCE (pinyins), NULL);
	self->content = (_tmp0_ = NULL, _g_free0 (self->content), _tmp0_);
	self->pinyins = (_tmp1_ = icp_pinyin_sequence_new_copy (pinyins, 0, -1), _icp_pinyin_sequence_unref0 (self->pinyins), _tmp1_);
	self->done = TRUE;
	self->retry = icp_config_limits_request_retry_limit;
	return self;
}


static icpIBusBindingCloudPinyinEnginePendingSegment* icp_ibus_binding_cloud_pinyin_engine_pending_segment_new_from_pinyins (icpPinyinSequence* pinyins) {
	return icp_ibus_binding_cloud_pinyin_engine_pending_segment_construct_from_pinyins (ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT, pinyins);
}


static icpIBusBindingCloudPinyinEnginePendingSegment* icp_ibus_binding_cloud_pinyin_engine_pending_segment_construct (GType object_type) {
	icpIBusBindingCloudPinyinEnginePendingSegment* self = (icpIBusBindingCloudPinyinEnginePendingSegment*) g_type_create_instance (object_type);
	return self;
}


static icpIBusBindingCloudPinyinEnginePendingSegment* icp_ibus_binding_cloud_pinyin_engine_pending_segment_new (void) {
	return icp_ibus_binding_cloud_pinyin_engine_pending_segment_construct (ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT);
}


static void icp_ibus_binding_cloud_pinyin_engine_value_pending_segment_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_ibus_binding_cloud_pinyin_engine_value_pending_segment_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref (value->data[0].v_pointer);
	}
}


static void icp_ibus_binding_cloud_pinyin_engine_value_pending_segment_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_ibus_binding_cloud_pinyin_engine_pending_segment_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_ibus_binding_cloud_pinyin_engine_value_pending_segment_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_ibus_binding_cloud_pinyin_engine_value_pending_segment_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpIBusBindingCloudPinyinEnginePendingSegment* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_ibus_binding_cloud_pinyin_engine_pending_segment_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_ibus_binding_cloud_pinyin_engine_value_pending_segment_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpIBusBindingCloudPinyinEnginePendingSegment** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_ibus_binding_cloud_pinyin_engine_pending_segment_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* icp_ibus_binding_cloud_pinyin_engine_param_spec_pending_segment (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpIBusBindingCloudPinyinEngineParamSpecPendingSegment* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer icp_ibus_binding_cloud_pinyin_engine_value_get_pending_segment (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT), NULL);
	return value->data[0].v_pointer;
}


static void icp_ibus_binding_cloud_pinyin_engine_value_set_pending_segment (GValue* value, gpointer v_object) {
	icpIBusBindingCloudPinyinEnginePendingSegment* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_ibus_binding_cloud_pinyin_engine_pending_segment_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref (old);
	}
}


static void icp_ibus_binding_cloud_pinyin_engine_value_take_pending_segment (GValue* value, gpointer v_object) {
	icpIBusBindingCloudPinyinEnginePendingSegment* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_PENDING_SEGMENT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref (old);
	}
}


static void icp_ibus_binding_cloud_pinyin_engine_pending_segment_class_init (icpIBusBindingCloudPinyinEnginePendingSegmentClass * klass) {
	icp_ibus_binding_cloud_pinyin_engine_pending_segment_parent_class = g_type_class_peek_parent (klass);
	ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_PENDING_SEGMENT_CLASS (klass)->finalize = icp_ibus_binding_cloud_pinyin_engine_pending_segment_finalize;
}


static void icp_ibus_binding_cloud_pinyin_engine_pending_segment_instance_init (icpIBusBindingCloudPinyinEnginePendingSegment * self) {
	self->ref_count = 1;
}


static void icp_ibus_binding_cloud_pinyin_engine_pending_segment_finalize (icpIBusBindingCloudPinyinEnginePendingSegment* obj) {
	icpIBusBindingCloudPinyinEnginePendingSegment * self;
	self = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_PENDING_SEGMENT (obj);
	_g_free0 (self->content);
	_icp_pinyin_sequence_unref0 (self->pinyins);
}


static GType icp_ibus_binding_cloud_pinyin_engine_pending_segment_get_type (void) {
	static volatile gsize icp_ibus_binding_cloud_pinyin_engine_pending_segment_type_id__volatile = 0;
	if (g_once_init_enter (&icp_ibus_binding_cloud_pinyin_engine_pending_segment_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_ibus_binding_cloud_pinyin_engine_value_pending_segment_init, icp_ibus_binding_cloud_pinyin_engine_value_pending_segment_free_value, icp_ibus_binding_cloud_pinyin_engine_value_pending_segment_copy_value, icp_ibus_binding_cloud_pinyin_engine_value_pending_segment_peek_pointer, "p", icp_ibus_binding_cloud_pinyin_engine_value_pending_segment_collect_value, "p", icp_ibus_binding_cloud_pinyin_engine_value_pending_segment_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpIBusBindingCloudPinyinEnginePendingSegmentClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_ibus_binding_cloud_pinyin_engine_pending_segment_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpIBusBindingCloudPinyinEnginePendingSegment), 0, (GInstanceInitFunc) icp_ibus_binding_cloud_pinyin_engine_pending_segment_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_ibus_binding_cloud_pinyin_engine_pending_segment_type_id;
		icp_ibus_binding_cloud_pinyin_engine_pending_segment_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpIBusBindingCloudPinyinEnginePendingSegment", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_ibus_binding_cloud_pinyin_engine_pending_segment_type_id__volatile, icp_ibus_binding_cloud_pinyin_engine_pending_segment_type_id);
	}
	return icp_ibus_binding_cloud_pinyin_engine_pending_segment_type_id__volatile;
}


static gpointer icp_ibus_binding_cloud_pinyin_engine_pending_segment_ref (gpointer instance) {
	icpIBusBindingCloudPinyinEnginePendingSegment* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void icp_ibus_binding_cloud_pinyin_engine_pending_segment_unref (gpointer instance) {
	icpIBusBindingCloudPinyinEnginePendingSegment* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_PENDING_SEGMENT_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static gpointer _icp_config_colors_color_ref0 (gpointer self) {
	return self ? icp_config_colors_color_ref (self) : NULL;
}


static icpIBusBindingCloudPinyinEngineColorSegment* icp_ibus_binding_cloud_pinyin_engine_color_segment_construct (GType object_type, icpConfigColorsColor* color, guint start, gint end) {
	icpIBusBindingCloudPinyinEngineColorSegment* self = (icpIBusBindingCloudPinyinEngineColorSegment*) g_type_create_instance (object_type);
	icpConfigColorsColor* _tmp0_;
	g_return_val_if_fail (ICP_CONFIG_COLORS_IS_COLOR (color), NULL);
	self->priv->color = (_tmp0_ = _icp_config_colors_color_ref0 (color), _icp_config_colors_color_unref0 (self->priv->color), _tmp0_);
	self->priv->start = start;
	self->priv->end = end;
	return self;
}


static icpIBusBindingCloudPinyinEngineColorSegment* icp_ibus_binding_cloud_pinyin_engine_color_segment_new (icpConfigColorsColor* color, guint start, gint end) {
	return icp_ibus_binding_cloud_pinyin_engine_color_segment_construct (ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT, color, start, end);
}


static void icp_ibus_binding_cloud_pinyin_engine_color_segment_apply (icpIBusBindingCloudPinyinEngineColorSegment* self, IBusText* text) {
	g_return_if_fail (ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_IS_COLOR_SEGMENT (self));
	g_return_if_fail (IBUS_IS_TEXT (text));
	icp_config_colors_color_apply (self->priv->color, text, self->priv->start, self->priv->end);
}


static void icp_ibus_binding_cloud_pinyin_engine_value_color_segment_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_ibus_binding_cloud_pinyin_engine_value_color_segment_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_ibus_binding_cloud_pinyin_engine_color_segment_unref (value->data[0].v_pointer);
	}
}


static void icp_ibus_binding_cloud_pinyin_engine_value_color_segment_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_ibus_binding_cloud_pinyin_engine_color_segment_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_ibus_binding_cloud_pinyin_engine_value_color_segment_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_ibus_binding_cloud_pinyin_engine_value_color_segment_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpIBusBindingCloudPinyinEngineColorSegment* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_ibus_binding_cloud_pinyin_engine_color_segment_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_ibus_binding_cloud_pinyin_engine_value_color_segment_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpIBusBindingCloudPinyinEngineColorSegment** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_ibus_binding_cloud_pinyin_engine_color_segment_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* icp_ibus_binding_cloud_pinyin_engine_param_spec_color_segment (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpIBusBindingCloudPinyinEngineParamSpecColorSegment* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer icp_ibus_binding_cloud_pinyin_engine_value_get_color_segment (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT), NULL);
	return value->data[0].v_pointer;
}


static void icp_ibus_binding_cloud_pinyin_engine_value_set_color_segment (GValue* value, gpointer v_object) {
	icpIBusBindingCloudPinyinEngineColorSegment* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_ibus_binding_cloud_pinyin_engine_color_segment_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_ibus_binding_cloud_pinyin_engine_color_segment_unref (old);
	}
}


static void icp_ibus_binding_cloud_pinyin_engine_value_take_color_segment (GValue* value, gpointer v_object) {
	icpIBusBindingCloudPinyinEngineColorSegment* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_TYPE_COLOR_SEGMENT));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_ibus_binding_cloud_pinyin_engine_color_segment_unref (old);
	}
}


static void icp_ibus_binding_cloud_pinyin_engine_color_segment_class_init (icpIBusBindingCloudPinyinEngineColorSegmentClass * klass) {
	icp_ibus_binding_cloud_pinyin_engine_color_segment_parent_class = g_type_class_peek_parent (klass);
	ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_COLOR_SEGMENT_CLASS (klass)->finalize = icp_ibus_binding_cloud_pinyin_engine_color_segment_finalize;
	g_type_class_add_private (klass, sizeof (icpIBusBindingCloudPinyinEngineColorSegmentPrivate));
}


static void icp_ibus_binding_cloud_pinyin_engine_color_segment_instance_init (icpIBusBindingCloudPinyinEngineColorSegment * self) {
	self->priv = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_COLOR_SEGMENT_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void icp_ibus_binding_cloud_pinyin_engine_color_segment_finalize (icpIBusBindingCloudPinyinEngineColorSegment* obj) {
	icpIBusBindingCloudPinyinEngineColorSegment * self;
	self = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_COLOR_SEGMENT (obj);
	_icp_config_colors_color_unref0 (self->priv->color);
}


static GType icp_ibus_binding_cloud_pinyin_engine_color_segment_get_type (void) {
	static volatile gsize icp_ibus_binding_cloud_pinyin_engine_color_segment_type_id__volatile = 0;
	if (g_once_init_enter (&icp_ibus_binding_cloud_pinyin_engine_color_segment_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_ibus_binding_cloud_pinyin_engine_value_color_segment_init, icp_ibus_binding_cloud_pinyin_engine_value_color_segment_free_value, icp_ibus_binding_cloud_pinyin_engine_value_color_segment_copy_value, icp_ibus_binding_cloud_pinyin_engine_value_color_segment_peek_pointer, "p", icp_ibus_binding_cloud_pinyin_engine_value_color_segment_collect_value, "p", icp_ibus_binding_cloud_pinyin_engine_value_color_segment_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpIBusBindingCloudPinyinEngineColorSegmentClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_ibus_binding_cloud_pinyin_engine_color_segment_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpIBusBindingCloudPinyinEngineColorSegment), 0, (GInstanceInitFunc) icp_ibus_binding_cloud_pinyin_engine_color_segment_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_ibus_binding_cloud_pinyin_engine_color_segment_type_id;
		icp_ibus_binding_cloud_pinyin_engine_color_segment_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpIBusBindingCloudPinyinEngineColorSegment", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_ibus_binding_cloud_pinyin_engine_color_segment_type_id__volatile, icp_ibus_binding_cloud_pinyin_engine_color_segment_type_id);
	}
	return icp_ibus_binding_cloud_pinyin_engine_color_segment_type_id__volatile;
}


static gpointer icp_ibus_binding_cloud_pinyin_engine_color_segment_ref (gpointer instance) {
	icpIBusBindingCloudPinyinEngineColorSegment* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void icp_ibus_binding_cloud_pinyin_engine_color_segment_unref (gpointer instance) {
	icpIBusBindingCloudPinyinEngineColorSegment* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_COLOR_SEGMENT_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void icp_ibus_binding_cloud_pinyin_engine_class_init (icpIBusBindingCloudPinyinEngineClass * klass) {
	icp_ibus_binding_cloud_pinyin_engine_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (icpIBusBindingCloudPinyinEnginePrivate));
	IBUS_ENGINE_CLASS (klass)->reset = icp_ibus_binding_cloud_pinyin_engine_real_reset;
	IBUS_ENGINE_CLASS (klass)->enable = icp_ibus_binding_cloud_pinyin_engine_real_enable;
	IBUS_ENGINE_CLASS (klass)->disable = icp_ibus_binding_cloud_pinyin_engine_real_disable;
	IBUS_ENGINE_CLASS (klass)->focus_in = icp_ibus_binding_cloud_pinyin_engine_real_focus_in;
	IBUS_ENGINE_CLASS (klass)->focus_out = icp_ibus_binding_cloud_pinyin_engine_real_focus_out;
	IBUS_ENGINE_CLASS (klass)->property_activate = icp_ibus_binding_cloud_pinyin_engine_real_property_activate;
	IBUS_ENGINE_CLASS (klass)->process_key_event = icp_ibus_binding_cloud_pinyin_engine_real_process_key_event;
	IBUS_ENGINE_CLASS (klass)->page_up = icp_ibus_binding_cloud_pinyin_engine_real_page_up;
	IBUS_ENGINE_CLASS (klass)->page_down = icp_ibus_binding_cloud_pinyin_engine_real_page_down;
	IBUS_ENGINE_CLASS (klass)->candidate_clicked = icp_ibus_binding_cloud_pinyin_engine_real_candidate_clicked;
	G_OBJECT_CLASS (klass)->finalize = icp_ibus_binding_cloud_pinyin_engine_finalize;
}


static void icp_ibus_binding_cloud_pinyin_engine_instance_init (icpIBusBindingCloudPinyinEngine * self) {
	char* _tmp0_;
	IBusText* _tmp1_;
	char* _tmp2_;
	IBusText* _tmp3_;
	char* _tmp4_;
	IBusText* _tmp5_;
	char* _tmp6_;
	IBusText* _tmp7_;
	IBusText* _tmp8_;
	IBusText* _tmp9_;
	self->priv = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE_GET_PRIVATE (self);
	self->priv->raw_buffer = g_strdup ("");
	self->priv->correction_mode = FALSE;
	self->priv->last_is_chinese = TRUE;
	self->priv->cloud_candidate_count = 0;
	self->priv->chinese_mode_icon = g_object_ref_sink (ibus_property_new ("mode", PROP_TYPE_NORMAL, NULL, _tmp0_ = g_strconcat (icp_config_get_global_data_path (), "/icons/pinyin-enabled.png", NULL), _tmp1_ = g_object_ref_sink (ibus_text_new_from_string ("/")), TRUE, TRUE, PROP_STATE_INCONSISTENT, NULL));
	_g_object_unref0 (_tmp1_);
	_g_free0 (_tmp0_);
	self->priv->traditional_conversion_icon = g_object_ref_sink (ibus_property_new ("trad", PROP_TYPE_NORMAL, NULL, _tmp2_ = g_strconcat (icp_config_get_global_data_path (), "/icons/traditional-disabled.png", NULL), _tmp3_ = g_object_ref_sink (ibus_text_new_from_string ("/")), FALSE, TRUE, PROP_STATE_INCONSISTENT, NULL));
	_g_object_unref0 (_tmp3_);
	_g_free0 (_tmp2_);
	self->priv->status_icon = g_object_ref_sink (ibus_property_new ("status", PROP_TYPE_NORMAL, NULL, _tmp4_ = g_strconcat (icp_config_get_global_data_path (), "/icons/idle-0.png", NULL), _tmp5_ = g_object_ref_sink (ibus_text_new_from_string ("/")), TRUE, TRUE, PROP_STATE_INCONSISTENT, NULL));
	_g_object_unref0 (_tmp5_);
	_g_free0 (_tmp4_);
	self->priv->tools_icon = g_object_ref_sink (ibus_property_new ("tools", PROP_TYPE_MENU, NULL, _tmp6_ = g_strconcat (icp_config_get_global_data_path (), "/icons/tools.png", NULL), _tmp7_ = g_object_ref_sink (ibus_text_new_from_string ("")), TRUE, TRUE, PROP_STATE_INCONSISTENT, NULL));
	_g_object_unref0 (_tmp7_);
	_g_free0 (_tmp6_);
	self->priv->tools_status_item = g_object_ref_sink (ibus_property_new ("tools_status", PROP_TYPE_NORMAL, _tmp8_ = g_object_ref_sink (ibus_text_new_from_string ("")), NULL, NULL, TRUE, TRUE, PROP_STATE_INCONSISTENT, NULL));
	_g_object_unref0 (_tmp8_);
	self->priv->tools_scel_import_item = g_object_ref_sink (ibus_property_new ("tools_scel_import", PROP_TYPE_NORMAL, _tmp9_ = g_object_ref_sink (ibus_text_new_from_string (" scel ")), NULL, NULL, TRUE, TRUE, PROP_STATE_INCONSISTENT, NULL));
	_g_object_unref0 (_tmp9_);
	self->priv->tools_menu_list = g_object_ref_sink (ibus_prop_list_new ());
	self->priv->panel_prop_list = g_object_ref_sink (ibus_prop_list_new ());
	self->priv->waiting_animation_timer = NULL;
	self->priv->last_chinese_mode = TRUE;
	self->priv->last_traditional_mode = FALSE;
	self->priv->last_offline_mode = FALSE;
	self->priv->waiting_index = 0;
	self->priv->waiting_index_acc = 1;
	self->priv->waiting_subindex = 0;
	self->priv->inited = FALSE;
	self->priv->last_prerequest_pinyins = g_strdup ("");
	self->priv->last_state = (guint) 0;
	self->priv->last_correction_mode = FALSE;
}


static void icp_ibus_binding_cloud_pinyin_engine_finalize (GObject* obj) {
	icpIBusBindingCloudPinyinEngine * self;
	self = ICP_IBUS_BINDING_CLOUD_PINYIN_ENGINE (obj);
	_g_free0 (self->priv->raw_buffer);
	_icp_pinyin_sequence_unref0 (self->priv->pinyin_buffer);
	_g_free0 (self->priv->pinyin_buffer_preedit);
	_g_object_unref0 (self->priv->pending_segment_list);
	_g_object_unref0 (self->priv->table);
	_g_object_unref0 (self->priv->chinese_mode_icon);
	_g_object_unref0 (self->priv->traditional_conversion_icon);
	_g_object_unref0 (self->priv->status_icon);
	_g_object_unref0 (self->priv->tools_icon);
	_g_object_unref0 (self->priv->tools_status_item);
	_g_object_unref0 (self->priv->tools_scel_import_item);
	_g_object_unref0 (self->priv->tools_menu_list);
	_g_object_unref0 (self->priv->panel_prop_list);
	_g_source_unref0 (self->priv->waiting_animation_timer);
	_g_free0 (self->priv->last_prerequest_pinyins);
	_g_object_unref0 (self->priv->user_pinyins);
	_g_free0 (self->priv->user_phrase);
	_g_free0 (self->priv->last_pinyin_buffer_string);
	G_OBJECT_CLASS (icp_ibus_binding_cloud_pinyin_engine_parent_class)->finalize (obj);
}


GType icp_ibus_binding_cloud_pinyin_engine_get_type (void) {
	static volatile gsize icp_ibus_binding_cloud_pinyin_engine_type_id__volatile = 0;
	if (g_once_init_enter (&icp_ibus_binding_cloud_pinyin_engine_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (icpIBusBindingCloudPinyinEngineClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_ibus_binding_cloud_pinyin_engine_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpIBusBindingCloudPinyinEngine), 0, (GInstanceInitFunc) icp_ibus_binding_cloud_pinyin_engine_instance_init, NULL };
		GType icp_ibus_binding_cloud_pinyin_engine_type_id;
		icp_ibus_binding_cloud_pinyin_engine_type_id = g_type_register_static (IBUS_TYPE_ENGINE, "icpIBusBindingCloudPinyinEngine", &g_define_type_info, 0);
		g_once_init_leave (&icp_ibus_binding_cloud_pinyin_engine_type_id__volatile, icp_ibus_binding_cloud_pinyin_engine_type_id);
	}
	return icp_ibus_binding_cloud_pinyin_engine_type_id__volatile;
}


static void icp_value_ibus_binding_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void icp_value_ibus_binding_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		icp_ibus_binding_unref (value->data[0].v_pointer);
	}
}


static void icp_value_ibus_binding_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = icp_ibus_binding_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer icp_value_ibus_binding_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* icp_value_ibus_binding_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		icpIBusBinding* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = icp_ibus_binding_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* icp_value_ibus_binding_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	icpIBusBinding** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = icp_ibus_binding_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* icp_param_spec_ibus_binding (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	icpParamSpecIBusBinding* spec;
	g_return_val_if_fail (g_type_is_a (object_type, ICP_TYPE_IBUS_BINDING), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer icp_value_get_ibus_binding (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_IBUS_BINDING), NULL);
	return value->data[0].v_pointer;
}


void icp_value_set_ibus_binding (GValue* value, gpointer v_object) {
	icpIBusBinding* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_IBUS_BINDING));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_TYPE_IBUS_BINDING));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		icp_ibus_binding_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_ibus_binding_unref (old);
	}
}


void icp_value_take_ibus_binding (GValue* value, gpointer v_object) {
	icpIBusBinding* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, ICP_TYPE_IBUS_BINDING));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, ICP_TYPE_IBUS_BINDING));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		icp_ibus_binding_unref (old);
	}
}


static void icp_ibus_binding_class_init (icpIBusBindingClass * klass) {
	icp_ibus_binding_parent_class = g_type_class_peek_parent (klass);
	ICP_IBUS_BINDING_CLASS (klass)->finalize = icp_ibus_binding_finalize;
}


static void icp_ibus_binding_instance_init (icpIBusBinding * self) {
	self->ref_count = 1;
}


static void icp_ibus_binding_finalize (icpIBusBinding* obj) {
	icpIBusBinding * self;
	self = ICP_IBUS_BINDING (obj);
}


GType icp_ibus_binding_get_type (void) {
	static volatile gsize icp_ibus_binding_type_id__volatile = 0;
	if (g_once_init_enter (&icp_ibus_binding_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { icp_value_ibus_binding_init, icp_value_ibus_binding_free_value, icp_value_ibus_binding_copy_value, icp_value_ibus_binding_peek_pointer, "p", icp_value_ibus_binding_collect_value, "p", icp_value_ibus_binding_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (icpIBusBindingClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) icp_ibus_binding_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (icpIBusBinding), 0, (GInstanceInitFunc) icp_ibus_binding_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType icp_ibus_binding_type_id;
		icp_ibus_binding_type_id = g_type_register_fundamental (g_type_fundamental_next (), "icpIBusBinding", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&icp_ibus_binding_type_id__volatile, icp_ibus_binding_type_id);
	}
	return icp_ibus_binding_type_id__volatile;
}


gpointer icp_ibus_binding_ref (gpointer instance) {
	icpIBusBinding* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void icp_ibus_binding_unref (gpointer instance) {
	icpIBusBinding* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		ICP_IBUS_BINDING_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




